<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title data-app="document-title">Todo Quest</title>
<style>
:root{
  --ink:#1b1e2e;
  --muted:#7d82a8;
  --tap:46px;
  --radius-card:16px;
  --radius-pill:999px;
  --gradient-main:linear-gradient(135deg,#8b7cff 0%,#b09bff 100%);
  --panel-bg:rgba(255,255,255,.85);
  --panel-border:rgba(0,0,0,.05);
  --panel-shadow:0 16px 40px rgba(0,0,0,.1);
  --glass-bg:rgba(255,255,255,.08);
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  color:var(--ink);
  font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
  background:#f6f7ff;
  background-attachment:fixed;
}

.wrap{
  max-width:960px;
  margin:12px auto;
  padding:20px;
}

h1{
  margin:0 0 12px;
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  gap:4px
}

h1 .app-title{
  font-size:24px;
  font-weight:600;
  color:#1b1e2e;
}

h1 .app-version{
  font-size:14px;
  font-weight:500;
  color:var(--muted);
}

/* Hero */
.hero{
  position:relative;
  border-radius:24px;
  background:var(--gradient-main);
  background-size:cover;
  background-position:center;
  color:#fff;
  overflow:hidden;
  margin-bottom:20px;
  box-shadow:0 24px 48px rgba(139,124,255,.35);
}
.hero::before{
  content:"";
  position:absolute;
  inset:0;
  background:linear-gradient(135deg,rgba(10,14,39,.55),rgba(10,14,39,.25));
}
.hero-inner{
  position:relative;
  z-index:1;
  display:flex;
  align-items:center;
  gap:24px;
  padding:28px;
}
.hero-character{
  width:140px;
  height:140px;
  flex-shrink:0;
  background-size:contain;
  background-repeat:no-repeat;
  background-position:center bottom;
  filter:drop-shadow(0 12px 24px rgba(0,0,0,.45));
}
.hero-info{flex:1;min-width:0}
.hero-name{
  margin:0;
  font-size:26px;
  font-weight:700;
  letter-spacing:.4px;
}
.hero-meta{
  margin-top:8px;
  display:flex;
  flex-wrap:wrap;
  gap:12px;
  font-size:16px;
  font-weight:500;
}
.hero-meta span{display:inline-flex;align-items:center;gap:6px}
.hero-progress{margin-top:18px;width:100%}
.hero-progress-bar{
  height:10px;
  background:rgba(255,255,255,.35);
  border-radius:999px;
  overflow:hidden;
}
.hero-progress-fill{
  height:100%;
  width:0;
  background:rgba(255,255,255,.95);
  box-shadow:0 6px 18px rgba(255,255,255,.35);
  border-radius:999px;
}
.hero-progress-label{
  margin-top:8px;
  font-size:14px;
  letter-spacing:.2px;
  opacity:.9;
}

/* Tabs bar */
.tabs{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin-bottom:16px;
  overflow-x:auto;
  padding-bottom:4px;
}
.tabs::-webkit-scrollbar{height:6px}
.tabs::-webkit-scrollbar-thumb{background:#ddd;border-radius:6px}

.tab-btn{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:var(--tap);
  padding:8px 14px;
  border:1px solid var(--panel-border);
  background:rgba(255,255,255,.8);
  border-radius:12px;
  cursor:pointer;
  white-space:nowrap;
  font-weight:500;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
  color:#1b1e2e;
  font-size:18px;
}
.tab-btn.active{
  background:var(--gradient-main);
  color:#fff;
  border-color:transparent;
  box-shadow:0 10px 20px rgba(139,124,255,.4);
}

/* generic buttons */
.btn-primary{
  min-height:var(--tap);
  background:var(--gradient-main);
  color:#fff;border:none;border-radius:12px;
  padding:10px 14px;font-weight:500;
  cursor:pointer;
  box-shadow:0 10px 20px rgba(139,124,255,.4);
  font-size:14px;
}
.btn-ghost{
  min-height:var(--tap);
  background:rgba(255,255,255,.8);
  border:1px solid var(--panel-border);
  border-radius:12px;
  padding:10px 14px;
  font-size:14px;
  font-weight:500;
  color:#1b1e2e;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
  cursor:pointer;
}
.btn-ghost:active{
  transform:translateY(1px);
  box-shadow:0 4px 12px rgba(0,0,0,.12);
}
.btn-ghost[disabled],
.btn-ghost[data-loading]{
  cursor:progress;
  opacity:.6;
  box-shadow:none;
  transform:none;
}
.btn-danger{
  min-height:var(--tap);
  background:linear-gradient(135deg,#ff5f48 0%,#ff3425 100%);
  color:#fff;border:none;border-radius:12px;
  padding:10px 14px;font-weight:500;
  cursor:pointer;
  box-shadow:0 10px 20px rgba(255,60,48,.4);
  font-size:14px;
}

/* pills */
.pill{
  background:rgba(255,255,255,.8);
  border:1px solid var(--panel-border);
  border-radius:var(--radius-pill);
  padding:4px 10px;
  font-size:14px;
  font-weight:500;
  color:#1b1e2e;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
}
.task-points { 
  font-weight: bold; 
  margin-left: 8px; 
  font-size: 14px; 
}
.task-points.positive { color: #16a34a; }
.task-points.negative { color: #dc2626; }
.task-points.neutral { color: #4b5563; }
.task-kind{
  display:inline-flex;
  align-items:center;
  padding:2px 8px;
  margin-left:8px;
  font-size:11px;
  font-weight:600;
  border-radius:999px;
  text-transform:uppercase;
  letter-spacing:.4px;
  background:rgba(139,124,255,.18);
  color:#5a4cc1;
}
.task-kind.single{
  background:rgba(34,197,94,.18);
  color:#1f9d55;
}
.task-kind.recurring{
  background:rgba(59,130,246,.18);
  color:#2563eb;
}
.task-kind.recurring.negative{
  background:rgba(248,113,113,.18);
  color:#dc2626;
}
.task.done .task-kind{opacity:.7}
.muted{color:var(--muted);font-size:14px}
.top{
  display:flex;
  align-items:center;
  gap:8px;
  margin-bottom:12px;
  flex-wrap:wrap
}

/* Inputs */
input,select,textarea{
  height:var(--tap);
  padding:10px;
  border-radius:12px;
  border:1px solid rgba(0,0,0,.08);
  width:100%;
  font:inherit;
  font-size:14px;
  background:#fff;
  box-shadow:0 6px 16px rgba(0,0,0,.05);
}
input[type="checkbox"]{
  height:auto;width:auto;box-shadow:none;
}

/* layout (Settings rows) */
.grid{display:grid;gap:10px}
.row{
  display:grid;
  grid-template-columns:200px 1fr;
  gap:10px;
  align-items:flex-start;
}

.card{
  padding:16px;
  border:1px solid var(--panel-border);
  border-radius:16px;
  background:var(--panel-bg);
  margin-top:16px;
  box-shadow:var(--panel-shadow);
  position:relative;
  overflow:hidden;
}
.card h3{
  margin:0 0 12px;
  font-size:16px;
  font-weight:600;
  color:#1b1e2e;
}

.bar{
  height:10px;
  background:rgba(0,0,0,.07);
  border-radius:6px;
  overflow:hidden;
  margin-bottom:10px;
  box-shadow:inset 0 2px 4px rgba(0,0,0,.12);
}
.fill{
  height:100%;
  background:linear-gradient(90deg,#8b7cff 0%,#b09bff 100%);
}

/* task lists */
ul{list-style:none;margin:0;padding:0}
.zone{
  border:1px solid rgba(0,0,0,.05);
  border-radius:16px;
  margin:16px 0;
  background:rgba(255,255,255,.8);
  box-shadow:0 12px 32px rgba(0,0,0,.08);
  overflow:hidden;
}
.zone header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:12px 16px;
  border-bottom:1px solid rgba(0,0,0,.05);
  background:linear-gradient(135deg,#fafbff 0%,#f6f7ff 100%);
  font-weight:500;
  color:#1b1e2e;
}
.zone header.imgHead{
  color:#fff;
  border-bottom:1px solid rgba(255,255,255,.3);
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  background-blend-mode:normal;
}
.zone header.imgHead .badge{
  background:rgba(0,0,0,.4);
  color:#fff;
  border:1px solid rgba(255,255,255,.3);
}

.badge{
  font-size:12px;
  padding:2px 8px;
  border-radius:var(--radius-pill);
  background:#fff;
  border:1px solid rgba(0,0,0,.07);
  color:#1b1e2e;
  font-weight:500;
  box-shadow:0 4px 10px rgba(0,0,0,.08);
}

/* swipe task row */
li.task{
  position:relative;
  border-top:1px solid rgba(0,0,0,.03);
  background:transparent;
  padding:0;
  overflow:hidden;
}
.task-inner{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:12px 16px;
  background:transparent;
  transition:transform .2s;
}
.left{display:flex;align-items:center;gap:10px}
.done .txt{text-decoration:line-through;color:#9aa}
.creator{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0}
.left input[type="checkbox"]{transform:scale(1.25)}

.del-btn{
  position:absolute;
  right:0;
  top:0;
  bottom:0;
  width:60px;
  min-width:60px;
  padding:0;
  border:none;
  border-radius:0;
  background:linear-gradient(135deg,#ff5f48 0%,#ff3425 100%);
  color:#fff;
  font-size:20px;
  font-weight:600;
  line-height:1;
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow:-4px 0 16px rgba(0,0,0,.2);
  transition:transform .2s;
  transform:translateX(60px); /* ·∫©n ban ƒë·∫ßu */
}

li.task.show-del .task-inner{
  transform:translateX(-60px);
}
li.task.show-del .del-btn{
  transform:translateX(0);
}

/* t·∫Øt transition khi ƒëang k√©o */
li.task.dragging .task-inner{
  transition:none;
}
li.task.dragging .del-btn{
  transition:none;
}

/* public task add button */
.add-to-priority {
  padding: 4px 8px;
  font-size: 12px;
  min-height: auto;
  min-width: auto;
  height: auto;
}

/* Leaderboard table */
.table-wrap{
  overflow:auto;
  border:1px solid rgba(0,0,0,.05);
  border-radius:16px;
  background:rgba(255,255,255,.8);
  box-shadow:0 16px 32px rgba(0,0,0,.08);
}
table{
  width:100%;
  border-collapse:collapse;
  background:transparent;
  font-size:14px;
}
th,td{
  padding:12px 16px;
  border-bottom:1px solid rgba(0,0,0,.05);
  text-align:left;
  white-space:nowrap;
}
th{
  font-weight:600;
  color:#1b1e2e;
  background:rgba(255,255,255,.6)
}

/* Charts */
.chart-card canvas{
  width:100%;
  max-width:100%;
  height:160px;
  display:block;
}

/* thumb preview */
.thumb{
  width:48px;
  height:48px;
  border-radius:10px;
  border:1px solid rgba(0,0,0,.1);
  background-size:cover;
  background-position:center;
  background-color:#eee;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
}

  @media (max-width:768px){
    .row{grid-template-columns:1fr}
    .creator{flex-direction:column}
    h1 .app-title{font-size:20px}
  .hero-inner{flex-direction:column;align-items:flex-start;text-align:left;gap:18px;padding:22px}
  .hero-character{width:100px;height:100px}
  .hero-name{font-size:22px}
  .hero-meta{font-size:15px}
}
@media (max-width:480px){
  body{font-size:15px}
  .tab-btn{padding:8px 12px}
  .tabs{gap:6px}
}
	.ai-reason{
  font-size:12px;
  color:var(--muted);
  margin-left:28px;   /* canh th·∫≥ng h√†ng v·ªõi text task */
  margin-top:2px;
}

</style>
</head>
<body>

<div class="wrap">
  <h1>
    <span class="app-title" data-app="title">Todo Quest</span>
    <span class="app-version" data-app="version"></span>
  </h1>

  <section id="hero" class="hero">
    <div class="hero-inner">
      <div class="hero-character" data-hero="character" aria-hidden="true"></div>
      <div class="hero-info">
        <div class="hero-name" data-hero="name">Player</div>
        <div class="hero-meta">
          <span class="hero-level" data-hero="level">Level 1</span>
          <span class="hero-xp" data-hero="xp">0 E</span>
        </div>
        <div class="hero-progress">
          <div class="hero-progress-bar">
            <div class="hero-progress-fill" data-hero="xp-fill"></div>
          </div>
          <div class="hero-progress-label" data-hero="xp-label">0 / 100 E</div>
        </div>
      </div>
    </div>
  </section>

  <div class="tabs" id="tabsBar"></div>

  <div id="view">ƒêang n·∫°p‚Ä¶</div>
</div>

<script>
/* ==============================
   CONFIG
============================== */
const APP_NAME = 'Todo Quest';

const CONFIG = {
  VERSION:'1.0',
  ENDPOINT:'https://script.google.com/macros/s/AKfycbyQ3imjnhKrzmuz4-KbPNsHzpYGY_Mv45os1bZEPoQrQ-UM8RjJvCznfP5x6RB6QX_Qpw/exec',
  SETTINGS_PASS:'1000',
  HERO_LEVELS:[
    {
      minLevel:1,
      maxLevel:3,
      characterImg:"url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 120\"><circle cx=\"50\" cy=\"38\" r=\"26\" fill=\"%23f97316\"/><rect x=\"22\" y=\"64\" width=\"56\" height=\"44\" rx=\"18\" fill=\"%23fb923c\"/></svg>')",
      backgroundImg:'linear-gradient(135deg,#fde68a 0%,#f97316 100%)'
    },
    {
      minLevel:4,
      maxLevel:6,
      characterImg:"url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 120\"><circle cx=\"50\" cy=\"38\" r=\"26\" fill=\"%232563eb\"/><rect x=\"22\" y=\"64\" width=\"56\" height=\"44\" rx=\"18\" fill=\"%2393c5fd\"/></svg>')",
      backgroundImg:'linear-gradient(135deg,#bae6fd 0%,#2563eb 100%)'
    },
    {
      minLevel:7,
      characterImg:"url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 120\"><circle cx=\"50\" cy=\"38\" r=\"26\" fill=\"%237c3aed\"/><rect x=\"22\" y=\"64\" width=\"56\" height=\"44\" rx=\"18\" fill=\"%23c4b5fd\"/></svg>')",
      backgroundImg:'linear-gradient(135deg,#e9d5ff 0%,#7c3aed 100%)'
    }
  ]
};

const APP_VERSION = CONFIG.VERSION;

(function syncAppMeta(){
  const versionLabel = `v${APP_VERSION}`;
  document.title = `${APP_NAME} ‚Äì ${versionLabel}`;

  const nameEl = document.querySelector('[data-app="title"]');
  if(nameEl){
    nameEl.textContent = APP_NAME;
  }

  const versionEl = document.querySelector('[data-app="version"]');
  if(versionEl){
    versionEl.textContent = versionLabel;
  }
})();

/* ==============================
   LOCAL STORAGE KEYS
============================== */
const LS = {
  PROFILE:'tq_profile',
  ZONES:'tq_zones',
  TASKS:'tq_tasks',
  RECUR:'tq_recurring',
  DAY:'tq_sim_day',
  BONUS:'tq_bonus_flags',
  SPAWN:'tq_spawned_day',
  LBCACHE:'tq_lb_cache',
  PUBLIC_TASKS:'tq_public_tasks',
  HIST:'tq_hist',
  REALDATE:'tq_real_date'
};

const ZONE_KIND_LABELS = {
  'e':'Zone E',
  'priority':'Zone Quan tr·ªçng',
  'noise':'Zone Noise',
  'regular':'Zone Th∆∞·ªùng',
  'public':'Zone Giao vi·ªác'
};
const ZONE_KIND_ORDER = ['e','priority','noise','regular','public'];
const DEFAULT_ZONES = ZONE_KIND_ORDER.map((kind)=>({
  name: ZONE_KIND_LABELS[kind],
  kind,
  bg:''
}));

const DAILY_ZONE_KINDS = new Set(['e','noise']);

let cachedPublicTasks = null;
let lbTimer = null;


/* ==============================
   HERO ELEMENTS
============================== */
const heroEl = document.getElementById('hero');
const heroDefaultCharacter = "url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 120\"><circle cx=\"50\" cy=\"38\" r=\"26\" fill=\"%239ca3af\"/><rect x=\"22\" y=\"64\" width=\"56\" height=\"44\" rx=\"18\" fill=\"%23d1d5db\"/></svg>')";
const heroRefs = heroEl ? {
  character: heroEl.querySelector('[data-hero="character"]'),
  name: heroEl.querySelector('[data-hero="name"]'),
  level: heroEl.querySelector('[data-hero="level"]'),
  xp: heroEl.querySelector('[data-hero="xp"]'),
  xpFill: heroEl.querySelector('[data-hero="xp-fill"]'),
  xpLabel: heroEl.querySelector('[data-hero="xp-label"]')
} : {};

/* ==============================
   LEVEL CONFIG
============================== */
const LEVELS = [
  {lvl:1, need:100},
  {lvl:2, need:250},
  {lvl:3, need:500},
  {lvl:4, need:800},
  {lvl:5, need:1200},
  {lvl:6, need:1700},
  {lvl:7, need:2300},
  {lvl:8, need:3000},
  {lvl:9, need:3800},
];

/* ==============================
   GENERIC HELPERS
============================== */
function load(key, def){ try{ return JSON.parse(localStorage.getItem(key)) ?? def }catch{ return def } }
function save(key, val){ localStorage.setItem(key, JSON.stringify(val)) }

function formatSignedNumber(n){
  const val = Number(n)||0;
  return `${val>=0?'+':''}${val}`;
}
function todayDM(){
  const d=new Date();
  const dd=String(d.getDate()).padStart(2,'0');
  const mm=String(d.getMonth()+1).padStart(2,'0');
  return `${dd}-${mm}`;
}
function getLastRealDate(){
  return localStorage.getItem(LS.REALDATE) || '';
}
function setLastRealDate(val){
  if(val){
    localStorage.setItem(LS.REALDATE, val);
  }
}
function lastLevelCfg(){ return LEVELS[LEVELS.length-1]; }

/* ==============================
   AI TASK SCORING (FINAL)
============================== */
const AI_ENDPOINT = "https://todo-quest-proxyp260992.vercel.app/api/score"; // s·ª≠a ƒë√∫ng URL proxy ƒëang ch·∫°y


/**
 * Ch·∫•m ƒëi·ªÉm 1 task v√† tr·∫£ v·ªÅ object ƒë·∫ßy ƒë·ªß t·ª´ proxy.
 * @param {string} taskText
 * @param {string} zoneKind: 'e' | 'priority' | 'noise' | 'regular' | 'public'
 * @returns {{zone:string, category:string, points:number, reason:string}}
 */
async function getTaskPoints(taskText, zoneKind) {
  const zoneLabel = ZONE_KIND_LABELS[zoneKind] || "Zone Th∆∞·ªùng";
  const r = await fetch(AI_ENDPOINT, {
    method: "POST",
    headers: { "Content-Type": "application/json", "X-Scoring-Version": "v2" },
    body: JSON.stringify({ text: taskText, zone: zoneLabel })
  });
  if (!r.ok) return { points: 0, reason: "" };
  const data = await r.json();
  const reason = String(data.reason || "").trim().split(/\s+/).slice(0,10).join(" ");
  return { points: Number(data.points)||0, reason, category: data.category, zone: data.zone };
}

/* ==============================
   PROFILE / LEVEL / XP ("E")
============================== */
function getProfile(){
  let p = load(LS.PROFILE);
  if(!p){ p={name:'', level:1, xp:0}; save(LS.PROFILE,p); }
  return p;
}
function setName(name){
  const p=getProfile(); p.name=(name||'').trim(); save(LS.PROFILE,p);
  renderHero();
}
function addXP(delta){
  const p=getProfile();
  p.xp = Math.max(0, Number(p.xp||0)+Number(delta||0));
  while(true){
    const cfg = LEVELS.find(x=>x.lvl===p.level) || lastLevelCfg();
    const need = cfg.need || 0;
    if(need>0 && p.xp>=need){
      p.xp -= need;
      const maxLvl = lastLevelCfg().lvl;
      p.level = Math.min(maxLvl, p.level+1);
    } else {
      break;
    }
  }
  save(LS.PROFILE,p);
  scheduleAutoSync();
  renderHero();
}
function getLevelInfo(){
  const p=getProfile();
  const cfg = LEVELS.find(x=>x.lvl===p.level) || lastLevelCfg();
  return {level:p.level, xp:p.xp, need:cfg.need||0};
}
function resetPoints(){
  const p=getProfile(); p.level=1; p.xp=0; save(LS.PROFILE,p);
  renderHero();
}
function ensureName(){
  const p=getProfile();
  if(!p.name){
    const n=prompt('Nh·∫≠p t√™n ng∆∞·ªùi ch∆°i:');
    if(n) setName(n);
  }
}

/* ==============================
   HERO RENDERING
============================== */
function pickHeroConfigFor(level){
  const list = Array.isArray(CONFIG.HERO_LEVELS) ? CONFIG.HERO_LEVELS : [];
  const fallback = list[list.length-1] || null;
  for(const item of list){
    if(typeof item.level === 'number' && item.level === level) return item;
    if(Array.isArray(item.levels) && item.levels.includes(level)) return item;
    const min = typeof item.minLevel === 'number' ? item.minLevel : (typeof item.min === 'number' ? item.min : -Infinity);
    const max = typeof item.maxLevel === 'number' ? item.maxLevel : (typeof item.max === 'number' ? item.max : Infinity);
    if(level>=min && level<=max) return item;
  }
  return fallback;
}

function renderHero(){
  if(!heroEl) return;

  const profile = getProfile();
  const {level,xp,need} = getLevelInfo();
  const preset = pickHeroConfigFor(level) || {};
  const name = (profile.name || '').trim() || 'Player';
  const pct = need ? Math.min(100, Math.round(xp/need*100)) : 100;

  heroEl.style.backgroundImage = preset.backgroundImg || 'linear-gradient(135deg,#8b7cff 0%,#b09bff 100%)';

  if(heroRefs.character){
    heroRefs.character.style.backgroundImage = preset.characterImg || heroDefaultCharacter;
  }
  if(heroRefs.name){
    heroRefs.name.textContent = name;
  }
  if(heroRefs.level){
    heroRefs.level.textContent = `Level ${level}`;
  }
  if(heroRefs.xp){
    heroRefs.xp.textContent = `${xp} E`;
  }
  if(heroRefs.xpLabel){
    heroRefs.xpLabel.textContent = need ? `${xp} / ${need} E t·ªõi level ti·∫øp theo` : `${xp} E (t·ªëi ƒëa)`;
  }
  if(heroRefs.xpFill){
    heroRefs.xpFill.style.width = `${pct}%`;
  }
}

/* ==============================
   HISTORY SNAPSHOT (Stats)
============================== */
function getHist(){ return load(LS.HIST,[]); }
function setHist(h){ save(LS.HIST,h); }
function pushHistSnapshot(){
  const p=getProfile();
  const h=getHist();
  h.push({
    ts:Date.now(),
    level:p.level,
    xp:p.xp
  });
  if(h.length>60){
    h.splice(0, h.length-60);
  }
  setHist(h);
}

/* ==============================
   DAY / FLAGS
============================== */
function getDay(){
  let d=Number(localStorage.getItem(LS.DAY)||0);
  if(!d){ d=1; localStorage.setItem(LS.DAY,d); }
  return d;
}
function nextDay(){
  const d=getDay()+1;
  localStorage.setItem(LS.DAY,d);
  return d;
}
function loadFlags(){ return load(LS.BONUS,{}); }
function saveFlags(f){ save(LS.BONUS,f); }
function bonusGiven(zoneId){
  const day=getDay();
  const f=loadFlags();
  return !!(f[day] && f[day][zoneId]);
}
function markBonus(zoneId){
  const day=getDay();
  const f=loadFlags();
  if(!f[day]) f[day]={};
  f[day][zoneId]=true;
  saveFlags(f);
}
function clearFlagsFor(day){
  const f=loadFlags();
  delete f[day];
  saveFlags(f);
}

/* ==============================
   ZONES / TASKS / RECURRING
============================== */
function normalizeZoneRecord(raw, idx, idBase){
  if(!raw || typeof raw!=='object') return {changed:true, zone:null};
  const zone = {...raw};
  let changed=false;

  if(typeof zone.id!=='number'){
    zone.id = idBase + idx;
    changed=true;
  }

  zone.name = typeof zone.name==='string' ? zone.name.trim() : '';
  if(!zone.name){
    zone.name = `Zone ${idx+1}`;
    changed=true;
  }

  if(typeof zone.bg!=='string'){
    zone.bg='';
    changed=true;
  }

  if(!ZONE_KIND_LABELS[zone.kind]){
    const fallbackKind = DEFAULT_ZONES.find(d=>d.name===zone.name)?.kind || 'regular';
    zone.kind = fallbackKind;
    changed=true;
  }

  return {changed, zone};
}

function getZones(){
  const loaded = load(LS.ZONES, []);
  const idBase = Date.now();
  let zones = [];
  let changed=false;

  if(Array.isArray(loaded) && loaded.length){
    loaded.forEach((item, idx)=>{
      const {changed: rowChanged, zone} = normalizeZoneRecord(item, idx, idBase+idx*10);
      if(rowChanged) changed=true;
      if(zone) zones.push(zone);
    });
  }

  if(!zones.length){
    const base = Date.now();
    zones = DEFAULT_ZONES.map((z, idx)=>({
      id: base + idx,
      name: z.name,
      kind: z.kind,
      bg: z.bg
    }));
    changed=true;
  }

  const existingKinds = new Set(zones.map(z=>z.kind));
  const missingDefaults = DEFAULT_ZONES.filter(def=>!existingKinds.has(def.kind));
  if(missingDefaults.length){
    const base = Date.now();
    missingDefaults.forEach((def, idx)=>{
      zones.push({
        id: base + idx,
        name: def.name,
        kind: def.kind,
        bg: def.bg
      });
    });
    changed=true;
  }

  if(changed){
    setZones(zones);
  }

  return zones;
}
function setZones(z){ save(LS.ZONES,z) }
function sanitizeZoneInput(z){
  return {
    name: typeof z.name==='string' ? z.name.trim() : '',
    kind: ZONE_KIND_LABELS[z.kind] ? z.kind : 'regular',
    bg: typeof z.bg==='string' ? z.bg : ''
  };
}
function renderZoneKindOptions(selected){
  return ZONE_KIND_ORDER.map(kind=>`<option value="${kind}" ${kind===selected?'selected':''}>${ZONE_KIND_LABELS[kind]}</option>`).join('');
}
function addZone(z){
  const list=getZones();
  const clean = sanitizeZoneInput(z);
  clean.id = Date.now() + Math.floor(Math.random()*1000);
  if(!clean.name){
    clean.name = `Zone ${list.length+1}`;
  }
  setZones([...list, clean]);
}
function updZone(id,patch){
  const clean={...patch};
  if('name' in clean){
    clean.name = (clean.name||'').trim();
    if(!clean.name) delete clean.name;
  }
  if('bg' in clean && typeof clean.bg!=='string'){
    delete clean.bg;
  }
  if('kind' in clean){
    clean.kind = ZONE_KIND_LABELS[clean.kind] ? clean.kind : 'regular';
  }
  setZones(getZones().map(z=>z.id===id?{...z,...clean}:z));
}
function delZone(id){
  setZones(getZones().filter(z=>z.id!==id));
}

async function addRecurring(r){
  const rec = {...r};
  rec.id = Date.now() + Math.floor(Math.random()*1000);

  // L·∫•y zone ƒë·ªÉ bi·∫øt kind
  const zones = getZones();
  const z = zones.find(z => z.id == rec.zoneId);
  const zoneKind = z ? z.kind : 'regular';

  const ai = await getTaskPoints(rec.text, zoneKind);
  rec.points = ai.points; // l∆∞u ƒëi·ªÉm base cho recurring

  const list = [...getRecurring(), rec];
  save(LS.RECUR, list);
  return rec;
}

function delRecurring(id){
  save(LS.RECUR,getRecurring().filter(r=>r.id!==id));
}

function getRecurring(){ return load(LS.RECUR,[]) }

function getTasks(){
  const raw = load(LS.TASKS, []);
  if(!Array.isArray(raw)) return [];

  const recs = getRecurring();
  const recIndex = new Map();
  for(const r of recs){
    const key = `${Number(r.zoneId)}|${String(r.text||'')}`;
    if(!recIndex.has(key)) recIndex.set(key, []);
    recIndex.get(key).push(r);
  }

  let changed=false;
  const normalized = raw.map(item=>{
    if(!item || typeof item!=='object'){
      changed=true;
      return null;
    }

    const zoneId = Number(item.zoneId);
    let kind = item.kind==='recurring' ? 'recurring' : (item.kind==='single' ? 'single' : null);
    let recurringId = typeof item.recurringId==='number' ? item.recurringId : null;
    let done = !!item.done;
    let points = Number(item.points) || 0;

    if(kind===null){
      const key = `${zoneId}|${String(item.text||'')}`;
      const match = recIndex.get(key) || [];
      if(recurringId!=null){
        kind='recurring';
      }else if(match.length===1){
        kind='recurring';
        recurringId = match[0].id;
      }else{
        kind='single';
      }
      if(kind==='recurring' && done){
        done=false;
      }
    }

    if(kind==='recurring' && recurringId==null){
      const key = `${zoneId}|${String(item.text||'')}`;
      const match = recIndex.get(key) || [];
      if(match.length===1){
        recurringId = match[0].id;
      }
    }

    const next = { ...item, zoneId, done, kind, points };
    if(kind==='recurring'){
      const existing = typeof next.recurringId==='number' ? next.recurringId : null;
      next.recurringId = recurringId!=null ? recurringId : existing;
      // Set points from recurring
      const rec = recs.find(r => r.id === next.recurringId);
      if (rec) {
        next.points = Number(rec.points) || 0;
      }
    }else if('recurringId' in next){
      delete next.recurringId;
    }

    if(item.zoneId!==next.zoneId || item.done!==next.done || item.kind!==next.kind || (kind==='recurring' && item.recurringId!==next.recurringId) || (kind!=='recurring' && 'recurringId' in item) || item.points !== next.points){
      changed=true;
    }

    return next;
  }).filter(Boolean);

  if(changed){
    save(LS.TASKS, normalized);
  }

  return normalized;
}

function isTaskActiveToday(t){
  if(!t) return false;
  if(t.kind==='recurring') return true;
  if(t.kind==='single') return !t.done;
  return !t.done;
}

function getZoneActiveTasks(tasks, zoneId){
  return tasks.filter(t=>t.zoneId==zoneId && isTaskActiveToday(t));
}

function describeTaskKind(task, zone){
  if(task.kind==='recurring'){
    return zone && zone.kind==='noise' ? 'H·∫±ng ng√†y (-)' : 'H·∫±ng ng√†y';
  }
  return 'M·ªôt l·∫ßn';
}

function taskKindClass(task, zone){
  if(task.kind==='recurring'){
    return zone && zone.kind==='noise' ? 'task-kind recurring negative' : 'task-kind recurring';
  }
  return 'task-kind single';
}

function renderTaskKindBadge(task, zone){
  return `<span class="${taskKindClass(task, zone)}">${describeTaskKind(task, zone)}</span>`;
}

function renderTaskPoints(points, reasonText, zoneKind) {
  if (zoneKind === 'public') {
    return `<span class="task-points neutral" title="G·ª£i √Ω/Test ‚Äî kh√¥ng t√≠nh ƒëi·ªÉm">0</span>`;
  }
  const sign = points >= 0 ? '+' : '';
  const className = points >= 0 ? 'positive' : 'negative';
  const safe = String(reasonText || '').replace(/"/g, '&quot;');
  return `<span class="task-points ${className}" title="${safe}">${sign}${points}</span>`;
}


function setTasks(a){ save(LS.TASKS,a) }

/* ==============================
   PUBLIC TASKS
============================== */
function getPublicTasks() {
  if (cachedPublicTasks === null) {
    cachedPublicTasks = load(LS.PUBLIC_TASKS, []);
  }
  return cachedPublicTasks;
}
function setPublicTasks(tasks) {
  cachedPublicTasks = tasks;
  save(LS.PUBLIC_TASKS, tasks);
}

/* ==============================
   LB CACHE
============================== */
function getLBCache(){
  return load(LS.LBCACHE, { ts:0, list:[] });
}
function setLBCache(v){
  save(LS.LBCACHE, v);
}
function renderLBRows(rowsEl, list){
  if(!Array.isArray(list) || !list.length){
    rowsEl.innerHTML = '<tr><td colspan="5" class="muted">Ch∆∞a c√≥ d·ªØ li·ªáu</td></tr>';
    return;
  }
  list.sort((a,b)=>
    (b.level-a.level) || (b.xp-a.xp) || (a.name||'').localeCompare(b.name||'')
  );
  rowsEl.innerHTML = list.map((u,i)=>`
    <tr>
      <td>${i+1}</td>
      <td>${u.name||'-'}</td>
      <td>${u.level??'-'}</td>
      <td>${u.xp??'-'}</td>
      <td>${u.updatedAt?new Date(u.updatedAt).toLocaleString():'-'}</td>
    </tr>
  `).join('');
}

/* ==============================
   SPAWN RECURRING EACH DAY
============================== */
function spawnRecurringIfNeeded(){
  const mark = Number(localStorage.getItem(LS.SPAWN)||0);
  if(mark===getDay()) return;

  const weekday = new Date().getDay();
  const recs = getRecurring();
  const zones = getZones();
  const tasks = getTasks();
  const existingRecurring = new Set(
    tasks
      .filter(t=>t.kind==='recurring' && typeof t.recurringId==='number')
      .map(t=>t.recurringId)
  );
  const fallbackRecurringKeys = new Set(
    tasks
      .filter(t=>t.kind==='recurring' && typeof t.recurringId!=='number')
      .map(t=>`${t.zoneId}|${String(t.text||'')}`)
  );

  for(const r of recs){
    const match = r.type==='daily' ||
      (r.type==='weekly' && Array.isArray(r.days)&&r.days.includes(weekday));
    if(!match) continue;

    const z = zones.find(z=>z.id==r.zoneId);
    if(!z) continue;

    const recKey = `${r.zoneId}|${String(r.text||'')}`;
    if(existingRecurring.has(r.id) || fallbackRecurringKeys.has(recKey)) continue;

    const newTask = {
	  id: Date.now() + Math.random(),
	  text: r.text,
	  zoneId: r.zoneId,
	  done: false,
	  kind: 'recurring',
	  recurringId: r.id,
	  points: Number(r.points) || 0,
	  aiReason: r.reason || ''
	};


    tasks.push(newTask);
    existingRecurring.add(r.id);
    fallbackRecurringKeys.add(recKey);
  }

  setTasks(tasks);
  localStorage.setItem(LS.SPAWN, String(getDay()));
}

/* ==============================
   SYNC / LB FETCH
============================== */
function getSyncCfg(){ return { endpoint: CONFIG.ENDPOINT, autosync: true }; }

async function autoSync(){
  const cfg = getSyncCfg();
  if(!cfg.autosync || !cfg.endpoint) return;
  const p = getProfile();

  const form = new URLSearchParams({
    name:  (p.name || 'Player'),
    level: String(p.level || 1),
    xp:    String(p.xp   || 0)
  }).toString();

  try {
    const res = await fetch(cfg.endpoint, {
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body:form
    });
    if(!res.ok){
      console.warn('autoSync: server tr·∫£ m√£', res.status);
    }
  } catch(e){
    console.warn('autoSync failed', e);
  }
}

const scheduleAutoSync = (() => {
  let timer = null;
  const DELAY = 2000;
  return function scheduleAutoSync(){
    if(timer){
      clearTimeout(timer);
    }
    timer = setTimeout(()=>{
      timer = null;
      autoSync();
    }, DELAY);
  };
})();

async function fetchLeaderboardAndCache(){
  const cfg = getSyncCfg();
  if (!cfg.endpoint) return;

  // TƒÉng timeout v√† x·ª≠ l√Ω AbortError √™m
  const controller = new AbortController();
  const timeoutMs = 15000; // 15s (tr∆∞·ªõc l√† 8000)
  const t = setTimeout(() => controller.abort(), timeoutMs);

  try {
    const r = await fetch(cfg.endpoint, {
      signal: controller.signal,
      cache: 'no-store' // tr√°nh cache treo
    });
    clearTimeout(t);

    if (!r.ok) throw new Error('HTTP ' + r.status);

    const data = await r.json();
    if (Array.isArray(data.lb)) {
      setLBCache({ ts: Date.now(), list: data.lb });
    }
    if (Array.isArray(data.public_tasks)) {
      setPublicTasks(data.public_tasks);
    }
  } catch (e) {
    clearTimeout(t);
    // CH·ªà S·ª¨A L·∫†I 3 D√íNG N√ÄY: AbortError th√¨ im l·∫∑ng, kh√¥ng log c·∫£nh b√°o
    if (e && e.name === 'AbortError') {
      // console.debug('Leaderboard fetch timed out');
      return;
    }
    console.warn('fetchLeaderboardAndCache failed', e);
  }
}


function backgroundBoardRefresh(){
  // G·ªçi nh·∫π, kh√¥ng n√©m l·ªói ra console
  fetchLeaderboardAndCache().catch(() => {});
}


/* ==============================
   DANGER LOCAL WIPE
============================== */
function wipeLocalPlayer(){
  localStorage.removeItem(LS.PROFILE);
  localStorage.removeItem(LS.LBCACHE);
  localStorage.removeItem(LS.PUBLIC_TASKS);
  alert('ƒê√£ xo√° h·ªì s∆° local. Reload trang ƒë·ªÉ t·∫°o ng∆∞·ªùi ch∆°i m·ªõi.');
  location.reload();
}

/* ==============================
   END DAY / RESET
============================== */
function handleResetPoints(){
  if(confirm('Reset Level=1 & E=0?')){
    resetPoints();
    alert('ƒê√£ reset ƒëi·ªÉm.');
    render('settings');
  }
}

function performDayRollover(opts={}){
  const auto=!!opts.auto;
  if(isRolloverRunning) return false;
  isRolloverRunning=true;
  try{
    const zones=getZones();
    const tasks=getTasks();
    const todaySim=getDay();

    // Calculate productivity bonus
    const todayTasks = tasks.filter(t => isTaskActiveToday(t) && t.done);
    let totalDayPoints = 0;
    let noisePoints = 0;
    const noiseZone = zones.find(z => z.kind === 'noise');
    todayTasks.forEach(t => {
      totalDayPoints += t.points || 0;
      if (t.zoneId === noiseZone?.id) {
        noisePoints += t.points || 0;
      }
    });
    if (totalDayPoints >= 10 && noisePoints >= -1) {
      let bonus = 3;
      if (totalDayPoints >= 15) bonus = 5;
      if (totalDayPoints >= 20) bonus = 8;
      addXP(bonus);
    }

    // Daily penalty
    addXP(-5);

    pushHistSnapshot();

    clearFlagsFor(todaySim);
    nextDay();
    const remaining = tasks.filter(t=>t.kind!=='recurring');
    setTasks(remaining);
    localStorage.removeItem(LS.SPAWN);
    spawnRecurringIfNeeded();

    setLastRealDate(todayDM());

    if(!auto){
      alert('ƒê√£ qua ng√†y.');
    }

    autoSync()
      .then(()=>fetchLeaderboardAndCache())
      .catch(()=>{});

    renderHero();
    return true;
  } finally {
    isRolloverRunning=false;
  }
}

function handleEndDay(){
  if(performDayRollover({auto:false})){
    render('settings');
  }
}

function syncDayWithCalendar(){
  const today = todayDM();
  const lastReal = getLastRealDate();
  if(!lastReal){
    setLastRealDate(today);
    return false;
  }
  if(lastReal===today){
    return false;
  }
  return performDayRollover({auto:true});
}

function startDaySyncMonitoring(){
  if(daySyncTimer!==null) return;
  daySyncTimer=setInterval(()=>{
    if(syncDayWithCalendar()){
      render('tasks');
    }
  }, 60*1000);

  if(!daySyncVisHandler){
    daySyncVisHandler=()=>{
      if(!document.hidden && syncDayWithCalendar()){
        render('tasks');
      }
    };
    document.addEventListener('visibilitychange', daySyncVisHandler);
  }
}

function stopDaySyncMonitoring(){
  if(daySyncTimer!==null){
    clearInterval(daySyncTimer);
    daySyncTimer=null;
  }
  if(daySyncVisHandler){
    document.removeEventListener('visibilitychange', daySyncVisHandler);
    daySyncVisHandler=null;
  }
}

/* ==============================
   MINI CHART DRAWER
============================== */
function drawChart(canvasId, values){
  const cvs = document.getElementById(canvasId);
  if(!cvs) return;
  const ctx = cvs.getContext('2d');
  const W = cvs.width  = cvs.offsetWidth  || 300;
  const H = cvs.height = cvs.offsetHeight || 160;

  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "rgba(255,255,255,0.6)";
  ctx.fillRect(0,0,W,H);

  if(!values || !values.length){
    ctx.fillStyle="#555";
    ctx.font="14px system-ui";
    ctx.fillText("Ch∆∞a c√≥ d·ªØ li·ªáu", 10, 24);
    return;
  }

  const minV = Math.min(...values);
  const maxV = Math.max(...values);
  const padX=20, padY=20;
  const span = (maxV-minV)||1;

  ctx.lineWidth=3;
  const grad = ctx.createLinearGradient(0,0,W,0);
  grad.addColorStop(0,"#8b7cff");
  grad.addColorStop(1,"#b09bff");
  ctx.strokeStyle = grad;
  ctx.beginPath();
  values.forEach((v,i)=>{
    const x = padX + ( (W-2*padX) * (i/(values.length-1||1)) );
    const y = H-padY - ( (H-2*padY) * ((v-minV)/span) );
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();

  const lastIdx = values.length-1;
  const lastVal = values[lastIdx];
  const lastX = padX + ((W-2*padX)*(lastIdx/(values.length-1||1)));
  const lastY = H-padY - ((H-2*padY)*((lastVal-minV)/span));
  ctx.fillStyle="#ff3425";
  ctx.beginPath();
  ctx.arc(lastX,lastY,5,0,Math.PI*2);
  ctx.fill();

  ctx.font="12px system-ui";
  ctx.fillStyle="#1b1e2e";
  ctx.fillText(String(lastVal), lastX+8, lastY-8);
}

/* ==============================
   SWIPE TASK HANDLERS
============================== */
function attachSwipeHandlersForTasks(){
  const rows = [...document.querySelectorAll('li.task:not([data-public="true"])')];

  rows.forEach(li=>{
    const inner  = li.querySelector('.task-inner');
    const delBtn = li.querySelector('.del-btn');

    let startX = 0;
    let currentX = 0;
    let isDown = false;
    let opened = li.classList.contains('show-del');
    let justSwiped = false;
    let swipeResetTimer = null;

    function openRow(){
      li.classList.add('show-del');
      li.classList.remove('dragging');
      inner.style.transform = '';
      delBtn.style.transform = '';
      opened = true;
    }

    function closeRow(){
      li.classList.remove('show-del');
      li.classList.remove('dragging');
      inner.style.transform = '';
      delBtn.style.transform = 'translateX(60px)';
      opened = false;
      justSwiped = false;
      if(swipeResetTimer){
        clearTimeout(swipeResetTimer);
        swipeResetTimer = null;
      }
    }

    function applyDrag(dx){
      let offset = dx;
      if(offset < -60) offset = -60;
      if(offset > 0)   offset = 0;

      inner.style.transform = `translateX(${offset}px)`;

      const btnOffset = 60 + offset;
      delBtn.style.transform = `translateX(${btnOffset}px)`;
    }

    function startDrag(clientX){
      isDown = true;
      startX = clientX;
      currentX = clientX;
      li.classList.add('dragging');

      if(opened){
        inner.style.transform   = 'translateX(-60px)';
        delBtn.style.transform  = 'translateX(0px)';
      }
    }

    function moveDrag(clientX){
      if(!isDown) return;
      currentX = clientX;
      const dx = currentX - startX;

      if(opened){
        applyDrag(-60 + dx);
      }else{
        applyDrag(dx);
      }
    }

    function endDrag(){
      if(!isDown) return;
      isDown = false;

      const dx = currentX - startX;

      let openedViaSwipe = false;

      if(opened){
        if(dx > 30){
          closeRow();
        }else{
          openRow();
          openedViaSwipe = true;
        }
      }else{
        if(dx < -30){
          openRow();
          openedViaSwipe = true;
        }else{
          closeRow();
        }
      }

      if(openedViaSwipe){
        justSwiped = true;
        if(swipeResetTimer){
          clearTimeout(swipeResetTimer);
        }
        swipeResetTimer = setTimeout(()=>{
          justSwiped = false;
          swipeResetTimer = null;
        }, 250);
      }
    }

    // Touch
    li.addEventListener('touchstart', e=>{
      startDrag(e.touches[0].clientX);
    }, {passive:true});

    li.addEventListener('touchmove', e=>{
      if(!isDown) return;
      moveDrag(e.touches[0].clientX);
      e.preventDefault();
    }, {passive:false});

    li.addEventListener('touchend', ()=>{
      endDrag();
    });

    // Mouse
    li.addEventListener('mousedown', e=>{
      startDrag(e.clientX);
    });

    li.addEventListener('mousemove', e=>{
      if(!isDown) return;
      moveDrag(e.clientX);
    });

    li.addEventListener('mouseup', ()=>{
      endDrag();
    });

    li.addEventListener('mouseleave', ()=>{
      if(isDown){
        endDrag();
      }
    });

    inner.addEventListener('click', e=>{
      if(li.classList.contains('show-del')){
        if(justSwiped){
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        e.preventDefault();
        e.stopPropagation();
        closeRow();
      }
    });
  });

  document.querySelectorAll('.del-btn').forEach(btn=>{
    btn.onclick = (e)=>{
      e.stopPropagation();
      const id = Number(btn.dataset.id);
      setTasks(getTasks().filter(t=>t.id!==id));
      render('tasks');
    };
  });
}

/* ==============================
   VIEW FUNCTIONS
============================== */
const view = document.getElementById('view');
const tabsBar = document.getElementById('tabsBar');
let settingsUnlocked=false;
let daySyncTimer=null;
let daySyncVisHandler=null;
let isRolloverRunning=false;

function ensureSettingsAuth(){
  if(settingsUnlocked) return true;
  const pass=prompt('Nh·∫≠p m·∫≠t kh·∫©u Settings:');
  if(pass===CONFIG.SETTINGS_PASS){
    settingsUnlocked=true;
    return true;
  }
  alert('Sai m·∫≠t kh·∫©u');
  return false;
}

/* Build tabs bar */
function buildTabsBar(active){
  tabsBar.innerHTML = [
    {id:'tasks', label:'Nhi·ªám v·ª•', icon:'‚úÖ'},
    {id:'leaderboard', label:'Leaderboard', icon:'üèÜ'},
    {id:'stats', label:'Bi·ªÉu ƒë·ªì', icon:'üìà'},
    {id:'settings', label:'Settings', icon:'‚öôÔ∏è'}
  ].map(t=>`
    <button class="tab-btn ${t.id===active?'active':''}" data-tab="${t.id}" aria-label="${t.label}" title="${t.label}">
      ${t.icon}
    </button>
  `).join('');

  [...tabsBar.querySelectorAll('.tab-btn')].forEach(btn=>{
    btn.onclick=()=>{
      render(btn.dataset.tab);
    };
  });
}

/* TASKS */
async function viewTasks(){
  spawnRecurringIfNeeded();

  let zones=getZones();
  const tasks=getTasks();
  const publicTasks = getPublicTasks();
  const dateNowDM = todayDM();
  let priorityZone = zones.find(z => z.kind === 'priority');

  if (!priorityZone) {
    const fallback = DEFAULT_ZONES.find(z=>z.kind==='priority') || {name: 'Zone Quan tr·ªçng', kind: 'priority', bg: ''};
    const restored = {
      id: Date.now(),
      name: fallback.name,
      kind: fallback.kind,
      bg: fallback.bg
    };
    zones = [...zones, restored];
    setZones(zones);
    priorityZone = restored;
    alert('Kh√¥ng t√¨m th·∫•y Zone Quan tr·ªçng, h·ªá th·ªëng ƒë√£ t·∫°o m·ªõi ƒë·ªÉ b·∫°n ti·∫øp t·ª•c.');
  }

  const groups = zones.map(z=>{
    const zoneTasks = tasks
      .filter(t=>t.zoneId==z.id)
      .sort((a,b)=>{
        if(a.kind===b.kind) return Number(a.done)-Number(b.done);
        return a.kind==='recurring' ? -1 : 1;
      });

    let list;
    if (z.kind === 'public') {
      const suggestionTasks = publicTasks.map(pt => ({
        id: `public_${pt.id}`,
        text: pt.text,
        points: Number(pt.points) || 0,
        kind: 'single',
        zoneId: z.id,
        isPublic: true,
        done: false // Public tasks are suggestions, not done
      }));
      list = [...zoneTasks, ...suggestionTasks];
    } else {
      list = zoneTasks;
    }
    const activeList = list.filter(isTaskActiveToday);
    const activeDone = activeList.filter(t=>t.done).length;
    return {
      z,
      list,
      activeList,
      activeDone,
      activeTotal: activeList.length,
      kindLabel: ZONE_KIND_LABELS[z.kind] || 'Zone',
      progressText: z.kind === 'public' ? 'G·ª£i √Ω' : (activeList.length ? `${activeDone}/${activeList.length}` : '0')
    };
  });

  view.innerHTML = `
    <div class="top">
      <span class="pill">Ng√†y: <b>${dateNowDM}</b></span>
    </div>

    <div class="creator">
      <input id="taskText" placeholder="Th√™m nhi·ªám v·ª•‚Ä¶ (Enter)">
      <select id="taskZone">${zones.map(z=>`<option value="${z.id}">${z.name}</option>`).join('')}</select>
      <button class="btn-primary" id="btnAdd">Th√™m</button>
    </div>

    ${groups.map(g=>{
      const z=g.z;
      const headerClass = z.bg ? 'imgHead' : '';
      const headerStyle = z.bg
        ? `background-image:linear-gradient(0deg,rgba(0,0,0,.5),rgba(0,0,0,.15)),url('${z.bg}');`
        : '';
      const emptyStateHtml = `
        <li class="task">
          <div class="task-inner">
            <span class="muted">${z.kind==='public' ? 'Ch∆∞a c√≥ g·ª£i √Ω.' : 'Ch∆∞a c√≥ task trong Zone n√†y.'}</span>
          </div>
        </li>`;

      const listHtml = g.list.length
        ? g.list.map(t=>{
            if (t.isPublic) {
              const priorityAction = `<button class="btn-primary add-to-priority" data-text="${t.text}" data-points="${t.points}">+</button>`;
              return `
                <li class="task" data-public="true" data-text="${t.text}" data-points="${t.points}">
                  <div class="task-inner">
                    <div class="left">
                      <span class="txt">${t.text}</span>
                      ${renderTaskPoints(t.points, t.aiReason, z.kind)}
                      ${priorityAction}
                    </div>
                  </div>
                </li>
              `;
            }

            return `
              <li class="task ${t.done?'done':''}" data-id="${t.id}" data-kind="${t.kind||'single'}">
                <div class="task-inner">
                  <div class="left">
                    <input type="checkbox" data-id="${t.id}" ${t.done?'checked':''} ${z.kind==='public'?'disabled':''}>
                    <span class="txt">${t.text}</span>
                    ${renderTaskKindBadge(t, z)}
                    ${renderTaskPoints(t.points, t.aiReason, z.kind)}
                  </div>
                </div>
                ${t.aiReason ? `<div class="ai-reason">${t.aiReason}</div>` : ''}
                <button class="del-btn" data-id="${t.id}">√ó</button>
              </li>
            `;
          }).join('')
        : emptyStateHtml;

      return `
      <section class="zone">
        <header class="${headerClass}" style="${headerStyle}">
          <div><b>${z.name}</b> <span class="badge">${g.kindLabel}</span></div>
          <div class="badge">${g.progressText}</div>
        </header>
        <ul>
          ${listHtml}
        </ul>
      </section>`;
    }).join('')}
  `;

  const inp = document.getElementById('taskText');
  const sel = document.getElementById('taskZone');

  async function addNow(){
    const text=(inp.value||'').trim(); if(!text) return;
    const zoneId = Number(sel.value);
    const z = zones.find(z=>z.id==zoneId);
    if(!z) return;

    // Limit for Zone E
    if (z.kind === 'e') {
      const activeInE = getZoneActiveTasks(getTasks(), z.id).length;
      if (activeInE >= 5) {
        alert('Zone E ch·ªâ t·ªëi ƒëa 5 task/ng√†y!');
        return;
      }
    }

    const ai = await getTaskPoints(text, z.kind);
    const currentTasks = getTasks();
    const newTasks = [...currentTasks];

    if(DAILY_ZONE_KINDS.has(z.kind)){
      const recs = getRecurring();
      const existingRec = recs.find(r=>r.zoneId==z.id && r.type==='daily' && (r.text||'')===text);
      const rec = existingRec || await addRecurring({
        text,
        zoneId:z.id,
        type:'daily',
        autoKind:z.kind
      });
      const duplicate = newTasks.some(t=>t.zoneId==z.id && t.kind==='recurring' && t.recurringId===rec.id);
      if(!duplicate){
        newTasks.push({
		  id: Date.now() + Math.random(),
		  text,
		  zoneId: z.id,
		  done: false,
		  kind: 'recurring',
		  recurringId: rec.id,
                  points: ai.points,
		  aiCategory: ai.category,
		  aiReason: ai.reason,
		  zoneLabel: ai.zone
		});

      }
    } else {
      newTasks.push({
		  id: Date.now(),
		  text,
		  zoneId: z.id,
		  done: false,
		  kind: 'single',
                  points: ai.points,
		  aiCategory: ai.category,
		  aiReason: ai.reason,
		  zoneLabel: ai.zone
		});
    }

    setTasks(newTasks);
    inp.value='';
    render('tasks');
  }

  document.getElementById('btnAdd').onclick = addNow;
  inp.onkeydown=(e)=>{ if(e.key==='Enter') addNow(); };

  window.onkeydown=(e)=>{
    const tag=(document.activeElement?.tagName||'').toLowerCase();
    if(e.key==='Tab' && !['input','select','textarea','button'].includes(tag)){
      e.preventDefault();
      inp.focus();
    }
  };

  // tick task
  view.querySelectorAll('input[type="checkbox"]').forEach(cb=>{
    cb.onchange=()=>{
      const id=Number(cb.dataset.id);
      const t = getTasks().find(t=>t.id===id);
      if(!t) return;
      const z = zones.find(z=>z.id==t.zoneId);
      t.done = cb.checked;
      const delta = cb.checked ? (t.points || 0) : -(t.points || 0);
      addXP(delta);
      setTasks(getTasks().map(x=>x.id===id?t:x));
      render('tasks');
    };
  });

  // add to priority from public
  view.querySelectorAll('.add-to-priority').forEach(btn => {
    btn.onclick = async (e) => {
      e.stopPropagation();
      const text = btn.dataset.text;

      let zones = getZones();
      let priorityZone = zones.find(z => z.kind === 'priority');

      if (!priorityZone) {
        addZone({ name: 'Zone Quan tr·ªçng', kind: 'priority', bg: '' });
        zones = getZones();
        priorityZone = zones.find(z => z.kind === 'priority');
      }

      if (!priorityZone) {
        alert('Kh√¥ng th·ªÉ t·∫°o Zone Quan tr·ªçng.');
        return;
      }

      // Ch·∫•m l·∫°i theo Zone Priority
      const ai = await getTaskPoints(text, 'priority');

      const currentTasks = getTasks();
      const newTask = {
        id: Date.now(),
        text,
        zoneId: priorityZone.id,
        done: false,
        kind: 'single',
        points: ai.points,
        aiCategory: ai.category,
        aiReason: ai.reason,
        zoneLabel: ai.zone
      };
      setTasks([...currentTasks, newTask]);
      alert('ƒê√£ th√™m v√†o Zone Quan tr·ªçng!');
      render('tasks');
    };
  });


  attachSwipeHandlersForTasks();
}

/* LEADERBOARD */
function viewLeaderboard(){
  const cache = getLBCache();

  view.innerHTML = `
    <div class="card" style="margin-top:0">
      <h3>Leaderboard</h3>
      <div class="muted">
        D·ªØ li·ªáu ƒë∆∞·ª£c t·∫£i n·ªÅn khi m·ªü app. Nh·∫•n "T·∫£i l·∫°i" ƒë·ªÉ c·∫≠p nh·∫≠t.
      </div>
      <div style="margin:10px 0;display:flex;gap:8px;flex-wrap:wrap">
        <button class="btn-ghost" id="reload">T·∫£i l·∫°i</button>
        <p id="lbStatus" class="muted" style="margin:0"></p>
      </div>
      <div class="table-wrap">
        <table id="tbl">
          <thead>
            <tr>
              <th>#</th><th>Ng∆∞·ªùi ch∆°i</th><th>Level</th><th>E</th><th>C·∫≠p nh·∫≠t</th>
            </tr>
          </thead>
          <tbody id="rows"></tbody>
        </table>
      </div>
    </div>
  `;

  const rows = document.getElementById('rows');

  function fallbackLocalProfileList(){
    const p=getProfile();
    return [{
      name:p.name||'Player',
      level:p.level||1,
      xp:p.xp||0,
      updatedAt:new Date().toISOString()
    }];
  }

  renderLBRows(rows, cache.list.length ? cache.list : fallbackLocalProfileList());

  const reloadBtn = document.getElementById('reload');
  const statusEl = document.getElementById('lbStatus');
  reloadBtn.dataset.defaultLabel = reloadBtn.textContent;

  function setLoadingState(isLoading){
    if(isLoading){
      reloadBtn.disabled = true;
      reloadBtn.dataset.loading = 'true';
      reloadBtn.textContent = 'ƒêang t·∫£i...';
    }else{
      reloadBtn.disabled = false;
      reloadBtn.removeAttribute('data-loading');
      reloadBtn.textContent = reloadBtn.dataset.defaultLabel;
    }
  }

  reloadBtn.onclick = async ()=>{
    setLoadingState(true);
    statusEl.textContent = 'ƒêang t·∫£i b·∫£ng x·∫øp h·∫°ng...';
    try{
      await fetchLeaderboardAndCache();
      const fresh = getLBCache();
      renderLBRows(rows, fresh.list.length ? fresh.list : fallbackLocalProfileList());
      statusEl.textContent = `ƒê√£ c·∫≠p nh·∫≠t l√∫c ${new Date().toLocaleTimeString('vi-VN')}`;
    }catch(err){
      console.error(err);
      statusEl.textContent = 'Kh√¥ng th·ªÉ t·∫£i leaderboard. Vui l√≤ng th·ª≠ l·∫°i sau.';
    }finally{
      setLoadingState(false);
    }
  };
}

/* STATS */
function viewStats(){
  const hist = getHist();
  const last7  = hist.slice(-7 ).map(r=>r.xp);
  const last30 = hist.slice(-30).map(r=>r.xp);

  view.innerHTML = `
    <div class="card chart-card" style="margin-top:0">
      <h3>Bi·ªÉu ƒë·ªì 7 ng√†y (E)</h3>
      <canvas id="chart7"></canvas>
    </div>

    <div class="card chart-card">
      <h3>Bi·ªÉu ƒë·ªì 30 ng√†y (E)</h3>
      <canvas id="chart30"></canvas>
    </div>

    <div class="muted" style="margin-top:12px;font-size:13px">
      L·ªãch s·ª≠ ƒë∆∞·ª£c l∆∞u m·ªói l·∫ßn b·∫°n b·∫•m "Qua ng√†y".
    </div>
  `;

  drawChart("chart7", last7);
  drawChart("chart30", last30);
}

/* SETTINGS */
function viewSettings(){
  const p=getProfile();
  const zones=getZones();
  const recs=getRecurring();
  const {level,xp,need}=getLevelInfo();
  const dateNowDM=todayDM();

  view.innerHTML = `
    <div class="card" style="margin-top:0">
      <h3>Ng√†y & ƒêi·ªÉm</h3>
      <div class="row">
        <div>Th√¥ng tin hi·ªán t·∫°i</div>
        <div class="grid" style="grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:8px">
          <div class="pill">Ng√†y: <b>${dateNowDM}</b></div>
          <div class="pill">Level: <b>${level}</b></div>
          <div class="pill">E: <b>${xp}</b>${need?` / ${need}`:''}</div>
        </div>
      </div>
      <div class="bar"><div class="fill" style="width:${need?Math.min(100,Math.round(xp/need*100)):100}%;"></div></div>

      <div class="row">
        <div>H√†nh ƒë·ªông</div>
        <div class="grid" style="grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:8px">
          <button class="btn-ghost" id="btnEnd">Qua ng√†y</button>
          <button class="btn-danger" id="btnReset">Reset ƒëi·ªÉm</button>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>H·ªì s∆° ng∆∞·ªùi ch∆°i</h3>
      <div class="row">
        <div>T√™n ng∆∞·ªùi ch∆°i</div>
        <div class="grid" style="grid-template-columns:1fr auto;align-items:center">
          <input id="name" value="${p.name||''}">
          <button class="btn-primary" id="saveName">L∆∞u</button>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Zones</h3>
      <div class="grid">
        <div class="row"><div>T√™n Zone</div><input id="zName" placeholder="C√¥ng vi·ªác"></div>
        <div class="row"><div>Lo·∫°i Zone</div>
          <select id="zKind">${renderZoneKindOptions('regular')}</select>
        </div>
        <div class="row"><div>H√¨nh n·ªÅn Zone</div>
          <input id="zBg" type="file" accept="image/*">
        </div>
        <div class="row"><div></div><button class="btn-primary" id="addZone">+ Th√™m Zone</button></div>
      </div>

      <div class="table-wrap" style="margin-top:12px">
        <table>
          <thead>
            <tr>
              <th>T√™n</th>
              <th>Lo·∫°i</th>
              <th>N·ªÅn</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="zoneT">
            ${zones.map(z=>`
              <tr data-id="${z.id}">
                <td><input name="name" value="${z.name}"></td>
                <td>
                  <select name="kind">${renderZoneKindOptions(z.kind)}</select>
                </td>
                <td>
                  <div class="thumb" style="background-image:url('${z.bg||''}')"></div>
                  <input class="bgUpload" data-id="${z.id}" type="file" accept="image/*" style="margin-top:6px">
                </td>
                <td><button class="btn-danger zdel" data-id="${z.id}">Xo√°</button></td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3>Tasks l·∫∑p (H·∫±ng ng√†y / Theo tu·∫ßn)</h3>
      <div class="row"><div>M√¥ t·∫£</div><input id="rText" placeholder="T·∫≠p th·ªÉ d·ª•c 15‚Äô"></div>
      <div class="row"><div>Zone</div>
        <select id="rZone">
          ${zones.filter(z => !DAILY_ZONE_KINDS.has(z.kind) && z.kind !== 'public').map(z=>`<option value="${z.id}">${z.name}</option>`).join('')}
        </select>
      </div>
      <div class="row"><div>Ki·ªÉu</div>
        <select id="rType">
          <option value="daily">H·∫±ng ng√†y</option>
          <option value="weekly">Theo th·ª©</option>
        </select>
      </div>
      <div class="row" id="rDaysRow" style="display:none">
        <div>Ch·ªçn th·ª©</div>
        <div class="grid" style="grid-template-columns:repeat(7, minmax(40px,1fr));gap:4px;font-size:14px">
          ${['CN','T2','T3','T4','T5','T6','T7'].map((l,i)=>`
            <label style="display:flex;align-items:center;gap:4px">
              <input type="checkbox" value="${i}"> ${l}
            </label>
          `).join('')}
        </div>
      </div>
      <div class="row">
        <div></div>
        <button class="btn-primary" id="addRec">+ Th√™m Task l·∫∑p</button>
      </div>

      <div class="table-wrap" style="margin-top:12px">
        <table>
          <thead>
            <tr>
              <th>M√¥ t·∫£</th><th>Zone</th><th>Ki·ªÉu</th><th>Th·ª©</th><th>ƒêi·ªÉm</th><th></th>
            </tr>
          </thead>
          <tbody id="recT">
            ${recs.map(r=>{
              const zn = zones.find(z=>z.id==r.zoneId)?.name||'(xo√°)';
              return `
                <tr>
                  <td>${r.text}</td>
                  <td>${zn}</td>
                  <td>${r.type}</td>
                  <td>${r.type==='weekly'?(r.days||[]).join(', '):'-'}</td>
                  <td>${formatSignedNumber(r.points || 0)}</td>
                  <td><button class="btn-danger rdel" data-id="${r.id}">Xo√°</button></td>
                </tr>`;
            }).join('')}
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3>Qu·∫£n tr·ªã / D·ªØ li·ªáu c·ª•c b·ªô</h3>
      <div class="row">
        <div>Xo√° h·ªì s∆° ng∆∞·ªùi ch∆°i LOCAL (m√°y n√†y)</div>
        <div><button class="btn-danger" id="wipeLocalBtn">Xo√° h·ªì s∆° local</button></div>
      </div>
    </div>
  `;

  // helper ƒë·ªçc file => base64
  function readFileAsDataURL(file, cb){
    const reader=new FileReader();
    reader.onload=()=>cb(reader.result);
    reader.readAsDataURL(file);
  }

  /* Ng√†y & ƒêi·ªÉm buttons */
  document.getElementById('btnEnd').onclick = ()=>{ handleEndDay(); };
  document.getElementById('btnReset').onclick = ()=>{ handleResetPoints(); };

  /* H·ªì s∆° ng∆∞·ªùi ch∆°i */
  document.getElementById('saveName').onclick=()=>{
    setName(document.getElementById('name').value);
    alert('ƒê√£ l∆∞u');
  };

  /* Zone th√™m m·ªõi */
  document.getElementById('addZone').onclick=()=>{
    const nameInp=document.getElementById('zName');
    const kindSel=document.getElementById('zKind');
    const nameVal=nameInp.value.trim();
    if(!nameVal){ alert('Nh·∫≠p t√™n Zone'); return; }

    const file=document.getElementById('zBg').files[0];
    const kindVal=kindSel.value;

    function finishAdd(bgData){
      const z={
        name:nameVal,
        kind:kindVal,
        bg:bgData||''
      };
      addZone(z);
      nameInp.value='';
      kindSel.value='regular';
      document.getElementById('zBg').value='';
      viewSettings();
    }

    if(file){
      readFileAsDataURL(file, data=>finishAdd(data));
    }else{
      finishAdd('');
    }
  };

  /* Zone ch·ªânh s·ª≠a */
  const zoneTable=document.getElementById('zoneT');
  const handleZoneChange=(e)=>{
    const tr=e.target.closest('tr[data-id]'); if(!tr) return;
    const id=Number(tr.dataset.id);
    const name=e.target.name;
    if(!name) return;
    const val=e.target.value;
    updZone(id,{[name]:val});
  };
  zoneTable.oninput=handleZoneChange;
  zoneTable.onchange=handleZoneChange;

  /* Zone ƒë·ªïi h√¨nh n·ªÅn */
  document.querySelectorAll('.bgUpload').forEach(inp=>{
    inp.onchange=()=>{
      const file=inp.files[0];
      const id=Number(inp.dataset.id);
      if(!file) return;
      readFileAsDataURL(file, data=>{
        updZone(id,{bg:data});
        viewSettings();
      });
    };
  });

  /* Zone xo√° */
  document.querySelectorAll('.zdel').forEach(b=> b.onclick=()=>{
    delZone(Number(b.dataset.id));
    viewSettings();
  });

  /* Recurring */
  const typeSel=document.getElementById('rType');
  const daysRow=document.getElementById('rDaysRow');
  typeSel.onchange=()=>{
    daysRow.style.display = typeSel.value==='weekly'?'grid':'none';
  };

  document.getElementById('addRec').onclick=async ()=>{
    const text=document.getElementById('rText').value.trim();
    if(!text){ alert('Nh·∫≠p m√¥ t·∫£'); return; }
    const zoneId=Number(document.getElementById('rZone').value);
    const type=typeSel.value;
    const days=[...daysRow.querySelectorAll('input:checked')].map(c=>Number(c.value));
    if(type==='weekly' && !days.length){
      alert('Ch·ªçn th·ª©');
      return;
    }
    await addRecurring({text, zoneId, type, days});
    document.getElementById('rText').value = '';
    document.getElementById('rZone').selectedIndex = 0;
    typeSel.value = 'daily';
    daysRow.style.display = 'none';
    [...daysRow.querySelectorAll('input[type="checkbox"]')].forEach(cb => cb.checked = false);
    viewSettings();
  };

  document.querySelectorAll('.rdel').forEach(b=> b.onclick=()=>{
    delRecurring(Number(b.dataset.id));
    viewSettings();
  });

  /* Local wipe */
  document.getElementById('wipeLocalBtn').onclick = ()=>{
    if(confirm('Xo√° h·ªì s∆° local v√† cache leaderboard tr√™n m√°y n√†y?')){
      wipeLocalPlayer();
    }
  };
}

/* ==============================
   ROUTER
============================== */
let currentTab='tasks';

function render(tab){
  currentTab = tab;
  renderHero();
  buildTabsBar(tab);

  if(tab==='tasks'){
    stopDaySyncMonitoring();
    syncDayWithCalendar();
    viewTasks();
    startDaySyncMonitoring();
    return;
  }

  stopDaySyncMonitoring();

  if(tab==='leaderboard'){
    viewLeaderboard();
  } else if(tab==='stats'){
    viewStats();
  } else if(tab==='settings'){
    if(ensureSettingsAuth()){
      viewSettings();
    } else {
      render('tasks');
    }
  } else {
    render('tasks');
  }
}

/* ==============================
   BOOT
============================== */
ensureName();
render('tasks');
fetchLeaderboardAndCache().catch(()=>{});
backgroundBoardRefresh();
if(lbTimer===null){
  // Runs for the duration of the session to keep leaderboard data fresh.
  lbTimer = setInterval(()=>{
    fetchLeaderboardAndCache().catch(()=>{});
  }, 60000);
}
</script>
</body>
</html>
