<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Todo Quest</title>
<style>
:root{
  --ink:#1b1e2e;
  --muted:#7d82a8;
  --tap:46px;
  --radius-card:16px;
  --radius-pill:999px;
  --gradient-main:linear-gradient(135deg,#8b7cff 0%,#b09bff 100%);
  --panel-bg:rgba(255,255,255,.85);
  --panel-border:rgba(0,0,0,.05);
  --panel-shadow:0 16px 40px rgba(0,0,0,.1);
  --glass-bg:rgba(255,255,255,.08);
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  color:var(--ink);
  font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
  background:#f6f7ff;
  background-attachment:fixed;
}

.wrap{
  max-width:960px;
  margin:12px auto;
  padding:20px;
}

h1{
  margin:0 0 12px;
  font-size:24px;
  font-weight:600;
  color:#1b1e2e;
  display:flex;
  align-items:center;
  gap:8px
}

/* Hero */
.hero{
  position:relative;
  border-radius:24px;
  background:var(--gradient-main);
  background-size:cover;
  background-position:center;
  color:#fff;
  overflow:hidden;
  margin-bottom:20px;
  box-shadow:0 24px 48px rgba(139,124,255,.35);
}
.hero::before{
  content:"";
  position:absolute;
  inset:0;
  background:linear-gradient(135deg,rgba(10,14,39,.55),rgba(10,14,39,.25));
}
.hero-inner{
  position:relative;
  z-index:1;
  display:flex;
  align-items:center;
  gap:24px;
  padding:28px;
}
.hero-character{
  width:140px;
  height:140px;
  flex-shrink:0;
  background-size:contain;
  background-repeat:no-repeat;
  background-position:center bottom;
  filter:drop-shadow(0 12px 24px rgba(0,0,0,.45));
}
.hero-info{flex:1;min-width:0}
.hero-name{
  margin:0;
  font-size:26px;
  font-weight:700;
  letter-spacing:.4px;
}
.hero-meta{
  margin-top:8px;
  display:flex;
  flex-wrap:wrap;
  gap:12px;
  font-size:16px;
  font-weight:500;
}
.hero-meta span{display:inline-flex;align-items:center;gap:6px}
.hero-progress{margin-top:18px;width:100%}
.hero-progress-bar{
  height:10px;
  background:rgba(255,255,255,.35);
  border-radius:999px;
  overflow:hidden;
}
.hero-progress-fill{
  height:100%;
  width:0;
  background:rgba(255,255,255,.95);
  box-shadow:0 6px 18px rgba(255,255,255,.35);
  border-radius:999px;
}
.hero-progress-label{
  margin-top:8px;
  font-size:14px;
  letter-spacing:.2px;
  opacity:.9;
}

/* Tabs bar */
.tabs{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin-bottom:16px;
  overflow-x:auto;
  padding-bottom:4px;
}
.tabs::-webkit-scrollbar{height:6px}
.tabs::-webkit-scrollbar-thumb{background:#ddd;border-radius:6px}

.tab-btn{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:var(--tap);
  padding:8px 14px;
  border:1px solid var(--panel-border);
  background:rgba(255,255,255,.8);
  border-radius:12px;
  cursor:pointer;
  white-space:nowrap;
  font-weight:500;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
  color:#1b1e2e;
  font-size:18px;
}
.tab-btn.active{
  background:var(--gradient-main);
  color:#fff;
  border-color:transparent;
  box-shadow:0 10px 20px rgba(139,124,255,.4);
}

/* generic buttons */
.btn-primary{
  min-height:var(--tap);
  background:var(--gradient-main);
  color:#fff;border:none;border-radius:12px;
  padding:10px 14px;font-weight:500;
  cursor:pointer;
  box-shadow:0 10px 20px rgba(139,124,255,.4);
  font-size:14px;
}
.btn-ghost{
  min-height:var(--tap);
  background:rgba(255,255,255,.8);
  border:1px solid var(--panel-border);
  border-radius:12px;
  padding:10px 14px;
  font-size:14px;
  font-weight:500;
  color:#1b1e2e;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
  cursor:pointer;
}
.btn-danger{
  min-height:var(--tap);
  background:linear-gradient(135deg,#ff5f48 0%,#ff3425 100%);
  color:#fff;border:none;border-radius:12px;
  padding:10px 14px;font-weight:500;
  cursor:pointer;
  box-shadow:0 10px 20px rgba(255,60,48,.4);
  font-size:14px;
}

/* pills */
.pill{
  background:rgba(255,255,255,.8);
  border:1px solid var(--panel-border);
  border-radius:var(--radius-pill);
  padding:4px 10px;
  font-size:14px;
  font-weight:500;
  color:#1b1e2e;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
}
.task-kind{
  display:inline-flex;
  align-items:center;
  padding:2px 8px;
  margin-left:8px;
  font-size:11px;
  font-weight:600;
  border-radius:999px;
  text-transform:uppercase;
  letter-spacing:.4px;
  background:rgba(139,124,255,.18);
  color:#5a4cc1;
}
.task-kind.once{
  background:rgba(34,197,94,.18);
  color:#1f9d55;
}
.task-kind.daily{
  background:rgba(59,130,246,.18);
  color:#2563eb;
}
.task-score{
  margin-left:8px;
  font-size:13px;
  font-weight:600;
}
.task-score.positive{color:#16a34a;}
.task-score.negative{color:#dc2626;}
.task-score.pending{color:#9ca3af;}
.task.done .task-kind{opacity:.7}
.muted{color:var(--muted);font-size:14px}
.top{
  display:flex;
  align-items:center;
  gap:8px;
  margin-bottom:12px;
  flex-wrap:wrap
}

/* Inputs */
input,select,textarea{
  height:var(--tap);
  padding:10px;
  border-radius:12px;
  border:1px solid rgba(0,0,0,.08);
  width:100%;
  font:inherit;
  font-size:14px;
  background:#fff;
  box-shadow:0 6px 16px rgba(0,0,0,.05);
}
input[type="checkbox"]{
  height:auto;width:auto;box-shadow:none;
}

/* layout (Settings rows) */
.grid{display:grid;gap:10px}
.row{
  display:grid;
  grid-template-columns:200px 1fr;
  gap:10px;
  align-items:flex-start;
}

.card{
  padding:16px;
  border:1px solid var(--panel-border);
  border-radius:16px;
  background:var(--panel-bg);
  margin-top:16px;
  box-shadow:var(--panel-shadow);
  position:relative;
  overflow:hidden;
}
.card h3{
  margin:0 0 12px;
  font-size:16px;
  font-weight:600;
  color:#1b1e2e;
}

.bar{
  height:10px;
  background:rgba(0,0,0,.07);
  border-radius:6px;
  overflow:hidden;
  margin-bottom:10px;
  box-shadow:inset 0 2px 4px rgba(0,0,0,.12);
}
.fill{
  height:100%;
  background:linear-gradient(90deg,#8b7cff 0%,#b09bff 100%);
}

/* task lists */
ul{list-style:none;margin:0;padding:0}
.zone{
  border:1px solid rgba(0,0,0,.05);
  border-radius:16px;
  margin:16px 0;
  background:rgba(255,255,255,.8);
  box-shadow:0 12px 32px rgba(0,0,0,.08);
  overflow:hidden;
}
.zone header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:12px 16px;
  border-bottom:1px solid rgba(0,0,0,.05);
  background:linear-gradient(135deg,#fafbff 0%,#f6f7ff 100%);
  font-weight:500;
  color:#1b1e2e;
}
.zone header.imgHead{
  color:#fff;
  border-bottom:1px solid rgba(255,255,255,.3);
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  background-blend-mode:normal;
}
.zone header.imgHead .badge{
  background:rgba(0,0,0,.4);
  color:#fff;
  border:1px solid rgba(255,255,255,.3);
}

.badge{
  font-size:12px;
  padding:2px 8px;
  border-radius:var(--radius-pill);
  background:#fff;
  border:1px solid rgba(0,0,0,.07);
  color:#1b1e2e;
  font-weight:500;
  box-shadow:0 4px 10px rgba(0,0,0,.08);
}

/* swipe task row */
li.task{
  position:relative;
  border-top:1px solid rgba(0,0,0,.03);
  background:transparent;
  padding:0;
  overflow:hidden;
}
.task-inner{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:12px 16px;
  background:transparent;
  transition:transform .2s;
}
.left{display:flex;align-items:center;gap:10px}
.done .txt{text-decoration:line-through;color:#9aa}
.creator{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0}
.left input[type="checkbox"]{transform:scale(1.25)}
.task-actions{display:flex;align-items:center;gap:8px;margin-left:auto;}
.assign-btn{
  min-width:32px;
  height:32px;
  border-radius:10px;
  border:1px solid rgba(139,124,255,.2);
  background:rgba(139,124,255,.12);
  color:#5a4cc1;
  font-size:18px;
  font-weight:600;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  box-shadow:0 4px 10px rgba(0,0,0,.08);
}
.assign-btn:hover{background:rgba(139,124,255,.22);} 

.del-btn{
  position:absolute;
  right:0;
  top:0;
  bottom:0;
  width:60px;
  min-width:60px;
  padding:0;
  border:none;
  border-radius:0;
  background:linear-gradient(135deg,#ff5f48 0%,#ff3425 100%);
  color:#fff;
  font-size:20px;
  font-weight:600;
  line-height:1;
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow:-4px 0 16px rgba(0,0,0,.2);
  transition:transform .2s;
  transform:translateX(60px); /* ẩn ban đầu */
}

li.task.show-del .task-inner{
  transform:translateX(-60px);
}
li.task.show-del .del-btn{
  transform:translateX(0);
}

/* tắt transition khi đang kéo */
li.task.dragging .task-inner{
  transition:none;
}
li.task.dragging .del-btn{
  transition:none;
}


/* Leaderboard table */
.table-wrap{
  overflow:auto;
  border:1px solid rgba(0,0,0,.05);
  border-radius:16px;
  background:rgba(255,255,255,.8);
  box-shadow:0 16px 32px rgba(0,0,0,.08);
}
table{
  width:100%;
  border-collapse:collapse;
  background:transparent;
  font-size:14px;
}
th,td{
  padding:12px 16px;
  border-bottom:1px solid rgba(0,0,0,.05);
  text-align:left;
  white-space:nowrap;
}
th{
  font-weight:600;
  color:#1b1e2e;
  background:rgba(255,255,255,.6)
}

/* Charts */
.chart-card canvas{
  width:100%;
  max-width:100%;
  height:160px;
  display:block;
}

/* thumb preview */
.thumb{
  width:48px;
  height:48px;
  border-radius:10px;
  border:1px solid rgba(0,0,0,.1);
  background-size:cover;
  background-position:center;
  background-color:#eee;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
}

@media (max-width:768px){
  .row{grid-template-columns:1fr}
  .creator{flex-direction:column}
  h1{font-size:20px}
  .hero-inner{flex-direction:column;align-items:flex-start;text-align:left;gap:18px;padding:22px}
  .hero-character{width:100px;height:100px}
  .hero-name{font-size:22px}
  .hero-meta{font-size:15px}
}
@media (max-width:480px){
  body{font-size:15px}
  .tab-btn{padding:8px 12px}
  .tabs{gap:6px}
}
</style>
</head>
<body>

<div class="wrap">
  <h1>Todo Quest</h1>

  <section id="hero" class="hero">
    <div class="hero-inner">
      <div class="hero-character" data-hero="character" aria-hidden="true"></div>
      <div class="hero-info">
        <div class="hero-name" data-hero="name">Player</div>
        <div class="hero-meta">
          <span class="hero-level" data-hero="level">Level 1</span>
          <span class="hero-xp" data-hero="xp">0 E</span>
        </div>
        <div class="hero-progress">
          <div class="hero-progress-bar">
            <div class="hero-progress-fill" data-hero="xp-fill"></div>
          </div>
          <div class="hero-progress-label" data-hero="xp-label">0 / 100 E</div>
        </div>
      </div>
    </div>
  </section>

  <div class="tabs" id="tabsBar"></div>

  <div id="view">Đang nạp…</div>
</div>

<script>
/* ==============================
   CONFIG
============================== */
const CONFIG = {
  ENDPOINT:'https://script.google.com/macros/s/AKfycbyQ3imjnhKrzmuz4-KbPNsHzpYGY_Mv45os1bZEPoQrQ-UM8RjJvCznfP5x6RB6QX_Qpw/exec',
  SETTINGS_PASS:'1000',
  AI_SCORE_ENDPOINT:'',
  AI_SCORE_PROMPT:'',
  HERO_LEVELS:[
    {
      minLevel:1,
      maxLevel:3,
      characterImg:"url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 120\"><circle cx=\"50\" cy=\"38\" r=\"26\" fill=\"%23f97316\"/><rect x=\"22\" y=\"64\" width=\"56\" height=\"44\" rx=\"18\" fill=\"%23fb923c\"/></svg>')",
      backgroundImg:'linear-gradient(135deg,#fde68a 0%,#f97316 100%)'
    },
    {
      minLevel:4,
      maxLevel:6,
      characterImg:"url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 120\"><circle cx=\"50\" cy=\"38\" r=\"26\" fill=\"%232563eb\"/><rect x=\"22\" y=\"64\" width=\"56\" height=\"44\" rx=\"18\" fill=\"%2393c5fd\"/></svg>')",
      backgroundImg:'linear-gradient(135deg,#bae6fd 0%,#2563eb 100%)'
    },
    {
      minLevel:7,
      characterImg:"url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 120\"><circle cx=\"50\" cy=\"38\" r=\"26\" fill=\"%237c3aed\"/><rect x=\"22\" y=\"64\" width=\"56\" height=\"44\" rx=\"18\" fill=\"%23c4b5fd\"/></svg>')",
      backgroundImg:'linear-gradient(135deg,#e9d5ff 0%,#7c3aed 100%)'
    }
  ]
};

/* ==============================
   LOCAL STORAGE KEYS
============================== */
const LS = {
  PROFILE:'tq_profile',
  ZONES:'tq_zones',
  TASKS:'tq_tasks',
  RECUR:'tq_recurring',
  DAY:'tq_sim_day',
  BONUS:'tq_bonus_flags',
  SPAWN:'tq_spawned_day',
  LBCACHE:'tq_lb_cache',
  HIST:'tq_hist',
  REALDATE:'tq_real_date',
  POINT_RULES:'tq_point_rules',
  DAILY_SCORES:'tq_daily_scores'
};

const ZONE_KIND_LABELS = {
  'zone-e':'Zone E',
  'priority':'Zone Quan trọng',
  'regular':'Zone Thường',
  'noise':'Zone Noise',
  'shared':'Zone Giao việc'
};
const LEGACY_ZONE_KIND = {
  'daily-positive':'zone-e',
  'daily-negative':'noise'
};
const ZONE_KIND_ORDER = ['zone-e','priority','regular','noise','shared'];
const DEFAULT_ZONES = [
  {name:'Zone E', kind:'zone-e', bg:''},
  {name:'Zone Quan trọng', kind:'priority', bg:''},
  {name:'Zone Noise', kind:'noise', bg:''},
  {name:'Zone Thường', kind:'regular', bg:''},
  {name:'Zone Giao việc', kind:'shared', bg:''}
];

const DEFAULT_POINT_RULES = {
  zoneCompletion: {
    default: 1,
    regular: 1,
    priority: 1,
    'zone-e': 2,
    noise: -1,
    shared: 0
  },
  rollover: {
    rewardPerCompleted: 0,
    penaltyPerIncomplete: 0
  }
};

let cachedPointRules = null;

/* ==============================
   HERO ELEMENTS
============================== */
const heroEl = document.getElementById('hero');
const heroDefaultCharacter = "url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 120\"><circle cx=\"50\" cy=\"38\" r=\"26\" fill=\"%239ca3af\"/><rect x=\"22\" y=\"64\" width=\"56\" height=\"44\" rx=\"18\" fill=\"%23d1d5db\"/></svg>')";
const heroRefs = heroEl ? {
  character: heroEl.querySelector('[data-hero="character"]'),
  name: heroEl.querySelector('[data-hero="name"]'),
  level: heroEl.querySelector('[data-hero="level"]'),
  xp: heroEl.querySelector('[data-hero="xp"]'),
  xpFill: heroEl.querySelector('[data-hero="xp-fill"]'),
  xpLabel: heroEl.querySelector('[data-hero="xp-label"]')
} : {};

/* ==============================
   LEVEL CONFIG
============================== */
const LEVELS = [
  {lvl:1, need:100},
  {lvl:2, need:250},
  {lvl:3, need:500},
  {lvl:4, need:800},
  {lvl:5, need:1200},
  {lvl:6, need:1700},
  {lvl:7, need:2300},
  {lvl:8, need:3000},
  {lvl:9, need:3800},
];

/* ==============================
   GENERIC HELPERS
============================== */
function load(key, def){ try{ return JSON.parse(localStorage.getItem(key)) ?? def }catch{ return def } }
function save(key, val){ localStorage.setItem(key, JSON.stringify(val)) }

function clonePointRules(src){
  return {
    zoneCompletion: { ...(src?.zoneCompletion||{}) },
    rollover: { ...(src?.rollover||{}) }
  };
}

function normalizePointRules(input){
  const base = clonePointRules(DEFAULT_POINT_RULES);
  if(!input || typeof input!=='object') return base;

  if(input.zoneCompletion && typeof input.zoneCompletion==='object'){
    for(const [key, value] of Object.entries(input.zoneCompletion)){
      if(typeof value==='number' && Number.isFinite(value)){
        base.zoneCompletion[key]=value;
      }
    }
  }

  if(input.rollover && typeof input.rollover==='object'){
    for(const [key, value] of Object.entries(input.rollover)){
      if(typeof value==='number' && Number.isFinite(value)){
        base.rollover[key]=value;
      }
    }
  }

  return base;
}

function getPointRules(){
  if(!cachedPointRules){
    const stored = load(LS.POINT_RULES, null);
    cachedPointRules = normalizePointRules(stored);
  }
  return cachedPointRules;
}

function setPointRules(next){
  cachedPointRules = normalizePointRules(next);
  save(LS.POINT_RULES, cachedPointRules);
  return cachedPointRules;
}

function formatSignedNumber(n){
  const val = Number(n)||0;
  if(val>0) return `+${val}`;
  if(val<0) return `${val}`;
  return '0';
}
function todayDM(){
  const d=new Date();
  const dd=String(d.getDate()).padStart(2,'0');
  const mm=String(d.getMonth()+1).padStart(2,'0');
  return `${dd}-${mm}`;
}
function getLastRealDate(){
  return localStorage.getItem(LS.REALDATE) || '';
}
function setLastRealDate(val){
  if(val){
    localStorage.setItem(LS.REALDATE, val);
  }
}
function lastLevelCfg(){ return LEVELS[LEVELS.length-1]; }

/* ==============================
   PROFILE / LEVEL / XP ("E")
============================== */
function getProfile(){
  let p = load(LS.PROFILE);
  if(!p){ p={name:'', level:1, xp:0}; save(LS.PROFILE,p); }
  return p;
}
function setName(name){
  const p=getProfile(); p.name=(name||'').trim(); save(LS.PROFILE,p);
  renderHero();
}
function addXP(delta){
  const p=getProfile();
  p.xp = Math.max(0, Number(p.xp||0)+Number(delta||0));
  while(true){
    const cfg = LEVELS.find(x=>x.lvl===p.level) || lastLevelCfg();
    const need = cfg.need || 0;
    if(need>0 && p.xp>=need){
      p.xp -= need;
      const maxLvl = lastLevelCfg().lvl;
      p.level = Math.min(maxLvl, p.level+1);
    } else {
      break;
    }
  }
  save(LS.PROFILE,p);
  renderHero();
}
function getLevelInfo(){
  const p=getProfile();
  const cfg = LEVELS.find(x=>x.lvl===p.level) || lastLevelCfg();
  return {level:p.level, xp:p.xp, need:cfg.need||0};
}
function resetPoints(){
  const p=getProfile(); p.level=1; p.xp=0; save(LS.PROFILE,p);
  renderHero();
}
function ensureName(){
  const p=getProfile();
  if(!p.name){
    const n=prompt('Nhập tên người chơi:');
    if(n) setName(n);
  }
}

/* ==============================
   HERO RENDERING
============================== */
function pickHeroConfigFor(level){
  const list = Array.isArray(CONFIG.HERO_LEVELS) ? CONFIG.HERO_LEVELS : [];
  const fallback = list[list.length-1] || null;
  for(const item of list){
    if(typeof item.level === 'number' && item.level === level) return item;
    if(Array.isArray(item.levels) && item.levels.includes(level)) return item;
    const min = typeof item.minLevel === 'number' ? item.minLevel : (typeof item.min === 'number' ? item.min : -Infinity);
    const max = typeof item.maxLevel === 'number' ? item.maxLevel : (typeof item.max === 'number' ? item.max : Infinity);
    if(level>=min && level<=max) return item;
  }
  return fallback;
}

function renderHero(){
  if(!heroEl) return;

  const profile = getProfile();
  const {level,xp,need} = getLevelInfo();
  const preset = pickHeroConfigFor(level) || {};
  const name = (profile.name || '').trim() || 'Player';
  const pct = need ? Math.min(100, Math.round(xp/need*100)) : 100;

  heroEl.style.backgroundImage = preset.backgroundImg || 'linear-gradient(135deg,#8b7cff 0%,#b09bff 100%)';

  if(heroRefs.character){
    heroRefs.character.style.backgroundImage = preset.characterImg || heroDefaultCharacter;
  }
  if(heroRefs.name){
    heroRefs.name.textContent = name;
  }
  if(heroRefs.level){
    heroRefs.level.textContent = `Level ${level}`;
  }
  if(heroRefs.xp){
    heroRefs.xp.textContent = `${xp} E`;
  }
  if(heroRefs.xpLabel){
    heroRefs.xpLabel.textContent = need ? `${xp} / ${need} E tới level tiếp theo` : `${xp} E (tối đa)`;
  }
  if(heroRefs.xpFill){
    heroRefs.xpFill.style.width = `${pct}%`;
  }
}

/* ==============================
   HISTORY SNAPSHOT (Stats)
============================== */
function getHist(){ return load(LS.HIST,[]); }
function setHist(h){ save(LS.HIST,h); }
function pushHistSnapshot(){
  const p=getProfile();
  const h=getHist();
  h.push({
    ts:Date.now(),
    level:p.level,
    xp:p.xp
  });
  if(h.length>60){
    h.splice(0, h.length-60);
  }
  setHist(h);
}

/* ==============================
   DAY / FLAGS
============================== */
function getDay(){
  let d=Number(localStorage.getItem(LS.DAY)||0);
  if(!d){ d=1; localStorage.setItem(LS.DAY,d); }
  return d;
}
function nextDay(){
  const d=getDay()+1;
  localStorage.setItem(LS.DAY,d);
  return d;
}
function loadFlags(){ return load(LS.BONUS,{}); }
function saveFlags(f){ save(LS.BONUS,f); }
function bonusGiven(zoneId){
  const day=getDay();
  const f=loadFlags();
  return !!(f[day] && f[day][zoneId]);
}
function markBonus(zoneId){
  const day=getDay();
  const f=loadFlags();
  if(!f[day]) f[day]={};
  f[day][zoneId]=true;
  saveFlags(f);
}
function clearFlagsFor(day){
  const f=loadFlags();
  delete f[day];
  saveFlags(f);
}

/* ==============================
   DAILY SCORE TRACKING
============================== */
function createDailyScoreEntry(){
  return { total:0, noise:0 };
}
function pruneDailyScoreStore(store){
  const keys = Object.keys(store||{}).map(k=>Number(k)).filter(Number.isFinite).sort((a,b)=>a-b);
  const limit = 60;
  if(keys.length>limit){
    const removeCount = keys.length - limit;
    for(let i=0;i<removeCount;i++){
      delete store[keys[i]];
    }
  }
}
function loadDailyScores(){
  const raw = load(LS.DAILY_SCORES, {});
  return raw && typeof raw==='object' ? {...raw} : {};
}
function saveDailyScores(data){
  save(LS.DAILY_SCORES, data);
}
function getDailyScore(day){
  const d = Number(day ?? getDay());
  if(!Number.isFinite(d)) return createDailyScoreEntry();
  const all = loadDailyScores();
  const raw = all[d];
  return {
    total: Number(raw?.total) || 0,
    noise: Number(raw?.noise) || 0
  };
}
function resetDailyScore(day){
  const d = Number(day ?? getDay());
  if(!Number.isFinite(d)) return;
  const all = loadDailyScores();
  all[d] = createDailyScoreEntry();
  pruneDailyScoreStore(all);
  saveDailyScores(all);
}
function adjustDailyScore(delta, zoneKind, dayOverride){
  const amount = Number(delta);
  if(!Number.isFinite(amount) || amount===0) return;
  const d = Number(dayOverride ?? getDay());
  if(!Number.isFinite(d)) return;
  const all = loadDailyScores();
  const entryRaw = all[d];
  const entry = entryRaw && typeof entryRaw==='object' ? {...entryRaw} : createDailyScoreEntry();
  entry.total = Number(entry.total) || 0;
  entry.noise = Number(entry.noise) || 0;
  entry.total += amount;
  if(zoneKind==='noise'){
    entry.noise += amount;
  }
  all[d] = entry;
  pruneDailyScoreStore(all);
  saveDailyScores(all);
}

function applyScoreDelta(delta, meta={}){
  const amount = Number(delta);
  if(!Number.isFinite(amount) || amount===0) return 0;
  addXP(amount);
  adjustDailyScore(amount, meta.zoneKind || null, meta.dayOverride);
  return amount;
}

/* ==============================
   ZONES / TASKS / RECURRING
============================== */
/*
Zone obj:
{
  id,
  name,
  kind,
  bg
}
*/
const DAILY_ZONE_KINDS = new Set(['zone-e']);

function normalizeZoneRecord(raw, idx, idBase){
  if(!raw || typeof raw!=='object') return {changed:true, zone:null};
  const zone = {...raw};
  let changed=false;

  if(typeof zone.id!=='number'){
    zone.id = idBase + idx;
    changed=true;
  }

  zone.name = typeof zone.name==='string' ? zone.name.trim() : '';
  if(!zone.name){
    zone.name = `Zone ${idx+1}`;
    changed=true;
  }

  if(typeof zone.bg!=='string'){
    zone.bg='';
    changed=true;
  }

  zone.kind = LEGACY_ZONE_KIND[zone.kind] || zone.kind;

  if(!ZONE_KIND_LABELS[zone.kind]){
    const fallbackKind = DEFAULT_ZONES.find(d=>d.name===zone.name)?.kind || 'regular';
    zone.kind = fallbackKind;
    changed=true;
  }

  return {changed, zone};
}

function getZones(){
  const loaded = load(LS.ZONES, []);
  const idBase = Date.now();
  let zones = [];
  let changed=false;

  if(Array.isArray(loaded) && loaded.length){
    loaded.forEach((item, idx)=>{
      const {changed: rowChanged, zone} = normalizeZoneRecord(item, idx, idBase+idx*10);
      if(rowChanged) changed=true;
      if(zone) zones.push(zone);
    });
  }

  if(!zones.length){
    const base = Date.now();
    zones = DEFAULT_ZONES.map((z, idx)=>({
      id: base + idx,
      name: z.name,
      kind: z.kind,
      bg: z.bg
    }));
    changed=true;
  }

  if(changed){
    setZones(zones);
  }

  return zones;
}
function setZones(z){ save(LS.ZONES,z) }
function sanitizeZoneInput(z){
  const rawKind = LEGACY_ZONE_KIND[z.kind] || z.kind;
  return {
    name: typeof z.name==='string' ? z.name.trim() : '',
    kind: ZONE_KIND_LABELS[rawKind] ? rawKind : 'regular',
    bg: typeof z.bg==='string' ? z.bg : ''
  };
}
function renderZoneKindOptions(selected){
  return ZONE_KIND_ORDER.map(kind=>`<option value="${kind}" ${kind===selected?'selected':''}>${ZONE_KIND_LABELS[kind]}</option>`).join('');
}
function addZone(z){
  const list=getZones();
  const clean = sanitizeZoneInput(z);
  clean.id = Date.now() + Math.floor(Math.random()*1000);
  if(!clean.name){
    clean.name = `Zone ${list.length+1}`;
  }
  setZones([...list, clean]);
}
function updZone(id,patch){
  const clean={...patch};
  if('name' in clean){
    clean.name = (clean.name||'').trim();
    if(!clean.name) delete clean.name;
  }
  if('bg' in clean && typeof clean.bg!=='string'){
    delete clean.bg;
  }
  if('kind' in clean){
    clean.kind = LEGACY_ZONE_KIND[clean.kind] || clean.kind;
    clean.kind = ZONE_KIND_LABELS[clean.kind] ? clean.kind : 'regular';
  }
  setZones(getZones().map(z=>z.id===id?{...z,...clean}:z));
}
function delZone(id){
  setZones(getZones().filter(z=>z.id!==id));
}

function getRecurring(){
  const raw = load(LS.RECUR, []);
  if(!Array.isArray(raw)) return [];
  let changed=false;
  const list = raw.map(item=>{
    if(!item || typeof item!=='object'){
      changed=true;
      return null;
    }
    const rec = {...item};
    if(typeof rec.score!=='number' || !Number.isFinite(rec.score)){
      if('score' in rec){
        delete rec.score;
        changed=true;
      }
    }
    return rec;
  }).filter(Boolean);
  if(changed){
    save(LS.RECUR, list);
  }
  return list;
}
function setRecurring(list){ save(LS.RECUR, list); }
function addRecurring(r){
  const rec = {...r};
  rec.id = Date.now() + Math.floor(Math.random()*1000);
  const list = [...getRecurring(), rec];
  setRecurring(list);
  return rec;
}
function delRecurring(id){
  setRecurring(getRecurring().filter(r=>r.id!==id));
}
function updateRecurringScore(recId, score){
  if(typeof recId!=='number' || !Number.isFinite(score)) return;
  const list = getRecurring();
  let changed=false;
  const next = list.map(rec=>{
    if(rec.id===recId){
      if(rec.score!==score){
        rec = {...rec, score};
        changed=true;
      }
    }
    return rec;
  });
  if(changed){
    setRecurring(next);
  }
}

function getTasks(){
  const raw = load(LS.TASKS, []);
  if(!Array.isArray(raw)) return [];

  const recs = getRecurring();
  const recIndex = new Map();
  const recById = new Map();
  for(const r of recs){
    if(typeof r.id==='number'){
      recById.set(r.id, r);
    }
    const key = `${Number(r.zoneId)}|${String(r.text||'')}`;
    if(!recIndex.has(key)) recIndex.set(key, []);
    recIndex.get(key).push(r);
  }

  let changed=false;
  const normalized = raw.map(item=>{
    if(!item || typeof item!=='object'){
      changed=true;
      return null;
    }

    const zoneId = Number(item.zoneId);
    let kind = item.kind==='recurring' ? 'recurring' : (item.kind==='single' ? 'single' : null);
    let recurringId = typeof item.recurringId==='number' ? item.recurringId : null;
    let done = !!item.done;

    if(kind===null){
      const key = `${zoneId}|${String(item.text||'')}`;
      const match = recIndex.get(key) || [];
      if(recurringId!=null){
        kind='recurring';
      }else if(match.length===1){
        kind='recurring';
        recurringId = match[0].id;
      }else{
        kind='single';
      }
      if(kind==='recurring' && done){
        done=false;
      }
    }

    if(kind==='recurring' && recurringId==null){
      const key = `${zoneId}|${String(item.text||'')}`;
      const match = recIndex.get(key) || [];
      if(match.length===1){
        recurringId = match[0].id;
      }
    }

    const next = { ...item, zoneId, done, kind };
    if(kind==='recurring'){
      const existing = typeof next.recurringId==='number' ? next.recurringId : null;
      next.recurringId = recurringId!=null ? recurringId : existing;
    }else if('recurringId' in next){
      delete next.recurringId;
    }

    let nextScore = Number(item.aiScore);
    if(!Number.isFinite(nextScore)){
      nextScore = null;
    }
    if(kind==='recurring' && recurringId!=null && nextScore==null){
      const rec = recById.get(recurringId);
      if(rec && typeof rec.score==='number' && Number.isFinite(rec.score)){
        nextScore = rec.score;
      }
    }
    if(nextScore!=null){
      next.aiScore = nextScore;
    } else if('aiScore' in next){
      delete next.aiScore;
    }

    if(item.zoneId!==next.zoneId || item.done!==next.done || item.kind!==next.kind || (kind==='recurring' && item.recurringId!==next.recurringId) || (kind!=='recurring' && 'recurringId' in item) || item.aiScore!==next.aiScore){
      changed=true;
    }

    return next;
  }).filter(Boolean);

  if(changed){
    save(LS.TASKS, normalized);
  }

  return normalized;
}

function isTaskActiveToday(t){
  if(!t) return false;
  if(t.kind==='recurring') return true;
  if(t.kind==='single') return !t.done;
  return !t.done;
}

function getZoneActiveTasks(tasks, zoneId){
  return tasks.filter(t=>t.zoneId==zoneId && isTaskActiveToday(t));
}

function zoneTaskCompletionDelta(zone){
  const rules = getPointRules();
  const map = rules.zoneCompletion || {};
  const kind = zone && typeof zone.kind==='string' ? zone.kind : 'regular';
  if(typeof map[kind]==='number') return map[kind];
  if(typeof map.default==='number') return map.default;
  if(typeof map.regular==='number') return map.regular;
  const fallback = Object.values(map).find(v=>typeof v==='number');
  return typeof fallback==='number' ? fallback : 1;
}

function describeTaskKind(task){
  if(task.kind==='recurring'){
    return 'Hằng ngày';
  }
  return 'Một lần';
}

function taskKindClass(task){
  if(task.kind==='recurring'){
    return 'task-kind daily';
  }
  return 'task-kind once';
}

function renderTaskKindBadge(task){
  return `<span class="${taskKindClass(task)}">${describeTaskKind(task)}</span>`;
}

function setTasks(a){ save(LS.TASKS,a) }

function parseNumericScore(raw){
  if(typeof raw==='number' && Number.isFinite(raw)) return raw;
  if(typeof raw==='string'){
    const match = raw.match(/-?\d+(?:\.\d+)?/);
    if(match){
      const num = Number(match[0]);
      if(Number.isFinite(num)) return num;
    }
  }
  return null;
}

async function evaluateTaskScoreWithAI({text, zoneKind, taskType}){
  const zone = zoneKind || 'regular';
  const endpoint = (CONFIG.AI_SCORE_ENDPOINT||'').trim();
  const prompt = (CONFIG.AI_SCORE_PROMPT||'').trim();
  if(endpoint){
    try{
      const payload = {
        prompt,
        task: text,
        zoneKind: zone,
        taskType
      };
      const res = await fetch(endpoint, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify(payload)
      });
      if(res.ok){
        const contentType = res.headers.get('content-type')||'';
        let bodyData=null;
        if(contentType.includes('application/json')){
          bodyData = await res.json();
        } else {
          const textBody = await res.text();
          bodyData = {score:textBody};
        }
        const candidates = [
          bodyData?.score,
          bodyData?.points,
          bodyData?.result,
          bodyData?.value
        ];
        for(const val of candidates){
          const parsed = parseNumericScore(val);
          if(parsed!=null) return parsed;
        }
      }
    }catch(err){
      console.warn('evaluateTaskScoreWithAI failed', err);
    }
  }
  return zoneTaskCompletionDelta({kind:zone});
}

async function ensureTaskScore(task, zone){
  if(!task) return null;
  if(typeof task.aiScore==='number' && Number.isFinite(task.aiScore)){
    return task.aiScore;
  }
  const zoneKind = zone && typeof zone.kind==='string' ? zone.kind : 'regular';
  if(task.kind==='recurring' && typeof task.recurringId==='number'){
    const rec = getRecurring().find(r=>r.id===task.recurringId);
    if(rec && typeof rec.score==='number' && Number.isFinite(rec.score)){
      task.aiScore = rec.score;
      return rec.score;
    }
  }
  const score = await evaluateTaskScoreWithAI({
    text: task.text || '',
    zoneKind,
    taskType: task.kind==='recurring' ? 'daily' : 'single'
  });
  if(Number.isFinite(score)){
    task.aiScore = score;
    if(task.kind==='recurring' && typeof task.recurringId==='number'){
      updateRecurringScore(task.recurringId, score);
    }
    return score;
  }
  return null;
}

/* ==============================
   LB CACHE
============================== */
function getLBCache(){
  return load(LS.LBCACHE, { ts:0, list:[] });
}
function setLBCache(v){
  save(LS.LBCACHE, v);
}
function renderLBRows(rowsEl, list){
  if(!Array.isArray(list) || !list.length){
    rowsEl.innerHTML = '<tr><td colspan="5" class="muted">Chưa có dữ liệu</td></tr>';
    return;
  }
  list.sort((a,b)=>
    (b.level-a.level) || (b.xp-a.xp) || (a.name||'').localeCompare(b.name||'')
  );
  rowsEl.innerHTML = list.map((u,i)=>`
    <tr>
      <td>${i+1}</td>
      <td>${u.name||'-'}</td>
      <td>${u.level??'-'}</td>
      <td>${u.xp??'-'}</td>
      <td>${u.updatedAt?new Date(u.updatedAt).toLocaleString():'-'}</td>
    </tr>
  `).join('');
}

/* ==============================
   SPAWN RECURRING EACH DAY
============================== */
function spawnRecurringIfNeeded(){
  const mark = Number(localStorage.getItem(LS.SPAWN)||0);
  if(mark===getDay()) return;

  const weekday = new Date().getDay();
  const recs = getRecurring();
  const zones = getZones();
  const tasks = getTasks();
  const existingRecurring = new Set(
    tasks
      .filter(t=>t.kind==='recurring' && typeof t.recurringId==='number')
      .map(t=>t.recurringId)
  );
  const fallbackRecurringKeys = new Set(
    tasks
      .filter(t=>t.kind==='recurring' && typeof t.recurringId!=='number')
      .map(t=>`${t.zoneId}|${String(t.text||'')}`)
  );

  for(const r of recs){
    const match = r.type==='daily' ||
      (r.type==='weekly' && Array.isArray(r.days)&&r.days.includes(weekday));
    if(!match) continue;

    const z = zones.find(z=>z.id==r.zoneId);
    if(!z) continue;

    const recKey = `${r.zoneId}|${String(r.text||'')}`;
    if(existingRecurring.has(r.id) || fallbackRecurringKeys.has(recKey)) continue;

    const newTask = {
      id:Date.now()+Math.random(),
      text:r.text,
      zoneId:r.zoneId,
      done:false,
      kind:'recurring',
      recurringId:r.id
    };

    tasks.push(newTask);
    existingRecurring.add(r.id);
    fallbackRecurringKeys.add(recKey);
  }

  setTasks(tasks);
  localStorage.setItem(LS.SPAWN, String(getDay()));
}

/* ==============================
   SYNC / LB FETCH
============================== */
function getSyncCfg(){ return { endpoint: CONFIG.ENDPOINT, autosync: true }; }

async function autoSync(){
  const cfg = getSyncCfg();
  if(!cfg.autosync || !cfg.endpoint) return;
  const p = getProfile();

  const form = new URLSearchParams({
    name:  (p.name || 'Player'),
    level: String(p.level || 1),
    xp:    String(p.xp   || 0)
  }).toString();

  try {
    const res = await fetch(cfg.endpoint, {
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body:form
    });
    if(!res.ok){
      console.warn('autoSync: server trả mã', res.status);
    }
  } catch(e){
    console.warn('autoSync failed', e);
  }
}

async function fetchLeaderboardAndCache(){
  const cfg = getSyncCfg();
  if(!cfg.endpoint) return;

  const controller = new AbortController();
  const t = setTimeout(()=>controller.abort(),8000);
  try{
    const r = await fetch(cfg.endpoint, { signal: controller.signal });
    clearTimeout(t);
    if(!r.ok) throw new Error('HTTP '+r.status);
    const data = await r.json();
    if(Array.isArray(data)){
      setLBCache({ ts:Date.now(), list:data });
    }
  }catch(e){
    clearTimeout(t);
    console.warn('fetchLeaderboardAndCache failed', e);
  }
}

function backgroundBoardRefresh(){
  fetchLeaderboardAndCache().catch(()=>{});
}

/* ==============================
   DANGER LOCAL WIPE
============================== */
function wipeLocalPlayer(){
  localStorage.removeItem(LS.PROFILE);
  localStorage.removeItem(LS.LBCACHE);
  localStorage.removeItem(LS.POINT_RULES);
  localStorage.removeItem(LS.DAILY_SCORES);
  cachedPointRules=null;
  alert('Đã xoá hồ sơ local. Reload trang để tạo người chơi mới.');
  location.reload();
}

/* ==============================
   END DAY / RESET
============================== */
function handleResetPoints(){
  if(confirm('Reset Level=1 & E=0?')){
    resetPoints();
    alert('Đã reset điểm.');
    render('settings');
  }
}

function performDayRollover(opts={}){
  const auto=!!opts.auto;
  if(isRolloverRunning) return false;
  isRolloverRunning=true;
  try{
    const zones=getZones();
    const tasks=getTasks();
    const todaySim=getDay();
    const rolloverRules = getPointRules().rollover || {};
    const rewardPerCompleted = Number(rolloverRules.rewardPerCompleted ?? 0);
    const penaltyPerIncomplete = Number(rolloverRules.penaltyPerIncomplete ?? 0);

    for(const z of zones){
      if(!DAILY_ZONE_KINDS.has(z.kind)) continue;
      const zoneTasks = getZoneActiveTasks(tasks, z.id).filter(t=>t.kind==='recurring');
      const totalCount = zoneTasks.length;
      if(totalCount===0) continue;
      const incomplete = zoneTasks.filter(t=>!t.done).length;
      const completed = totalCount - incomplete;
      const delta = (completed * rewardPerCompleted) + (incomplete * penaltyPerIncomplete);
      if(delta!==0){
        applyScoreDelta(delta, {zoneKind: z.kind, dayOverride: todaySim});
      }
    }

    const todayScore = getDailyScore(todaySim);
    const totalToday = todayScore.total;
    const noiseToday = todayScore.noise;
    let bonus = 0;
    if(noiseToday >= -1 && totalToday >= 10){
      if(totalToday >= 20){
        bonus = 8;
      } else if(totalToday >= 15){
        bonus = 5;
      } else {
        bonus = 3;
      }
    }
    if(bonus){
      applyScoreDelta(bonus, {zoneKind:'bonus', dayOverride: todaySim});
    }

    pushHistSnapshot();

    clearFlagsFor(todaySim);
    const nextSim = nextDay();
    const remaining = tasks.filter(t=>t.kind!=='recurring');
    setTasks(remaining);
    localStorage.removeItem(LS.SPAWN);
    spawnRecurringIfNeeded();

    resetDailyScore(nextSim);
    applyScoreDelta(-5, {zoneKind:'penalty', dayOverride: nextSim});

    setLastRealDate(todayDM());

    if(!auto){
      alert('Đã qua ngày.');
    }

    autoSync()
      .then(()=>fetchLeaderboardAndCache())
      .catch(()=>{});

    renderHero();
    return true;
  } finally {
    isRolloverRunning=false;
  }
}

function handleEndDay(){
  if(performDayRollover({auto:false})){
    render('settings');
  }
}

function syncDayWithCalendar(){
  const today = todayDM();
  const lastReal = getLastRealDate();
  if(!lastReal){
    setLastRealDate(today);
    return false;
  }
  if(lastReal===today){
    return false;
  }
  return performDayRollover({auto:true});
}

function startDaySyncMonitoring(){
  if(daySyncTimer!==null) return;
  daySyncTimer=setInterval(()=>{
    if(syncDayWithCalendar()){
      render('tasks');
    }
  }, 60*1000);

  if(!daySyncVisHandler){
    daySyncVisHandler=()=>{
      if(!document.hidden && syncDayWithCalendar()){
        render('tasks');
      }
    };
    document.addEventListener('visibilitychange', daySyncVisHandler);
  }
}

function stopDaySyncMonitoring(){
  if(daySyncTimer!==null){
    clearInterval(daySyncTimer);
    daySyncTimer=null;
  }
  if(daySyncVisHandler){
    document.removeEventListener('visibilitychange', daySyncVisHandler);
    daySyncVisHandler=null;
  }
}

/* ==============================
   MINI CHART DRAWER
============================== */
function drawChart(canvasId, values){
  const cvs = document.getElementById(canvasId);
  if(!cvs) return;
  const ctx = cvs.getContext('2d');
  const W = cvs.width  = cvs.offsetWidth  || 300;
  const H = cvs.height = cvs.offsetHeight || 160;

  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "rgba(255,255,255,0.6)";
  ctx.fillRect(0,0,W,H);

  if(!values || !values.length){
    ctx.fillStyle="#555";
    ctx.font="14px system-ui";
    ctx.fillText("Chưa có dữ liệu", 10, 24);
    return;
  }

  const minV = Math.min(...values);
  const maxV = Math.max(...values);
  const padX=20, padY=20;
  const span = (maxV-minV)||1;

  ctx.lineWidth=3;
  const grad = ctx.createLinearGradient(0,0,W,0);
  grad.addColorStop(0,"#8b7cff");
  grad.addColorStop(1,"#b09bff");
  ctx.strokeStyle = grad;
  ctx.beginPath();
  values.forEach((v,i)=>{
    const x = padX + ( (W-2*padX) * (i/(values.length-1||1)) );
    const y = H-padY - ( (H-2*padY) * ((v-minV)/span) );
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();

  const lastIdx = values.length-1;
  const lastVal = values[lastIdx];
  const lastX = padX + ((W-2*padX)*(lastIdx/(values.length-1||1)));
  const lastY = H-padY - ((H-2*padY)*((lastVal-minV)/span));
  ctx.fillStyle="#ff3425";
  ctx.beginPath();
  ctx.arc(lastX,lastY,5,0,Math.PI*2);
  ctx.fill();

  ctx.font="12px system-ui";
  ctx.fillStyle="#1b1e2e";
  ctx.fillText(String(lastVal), lastX+8, lastY-8);
}

/* ==============================
   SWIPE TASK HANDLERS
============================== */
function attachSwipeHandlersForTasks(){
  const rows = [...document.querySelectorAll('li.task')];

  rows.forEach(li=>{
    const inner  = li.querySelector('.task-inner');
    const delBtn = li.querySelector('.del-btn');

    let startX = 0;
    let currentX = 0;
    let isDown = false;
    let opened = li.classList.contains('show-del');

    function openRow(){
      li.classList.add('show-del');
      li.classList.remove('dragging');
      inner.style.transform = '';
      delBtn.style.transform = '';
      opened = true;
    }

    function closeRow(){
      li.classList.remove('show-del');
      li.classList.remove('dragging');
      inner.style.transform = '';
      delBtn.style.transform = 'translateX(60px)';
      opened = false;
    }

    function applyDrag(dx){
      let offset = dx;
      if(offset < -60) offset = -60;
      if(offset > 0)   offset = 0;

      inner.style.transform = `translateX(${offset}px)`;

      const btnOffset = 60 + offset;
      delBtn.style.transform = `translateX(${btnOffset}px)`;
    }

    function startDrag(clientX){
      isDown = true;
      startX = clientX;
      currentX = clientX;
      li.classList.add('dragging');

      if(opened){
        inner.style.transform   = 'translateX(-60px)';
        delBtn.style.transform  = 'translateX(0px)';
      }
    }

    function moveDrag(clientX){
      if(!isDown) return;
      currentX = clientX;
      const dx = currentX - startX;

      if(opened){
        applyDrag(-60 + dx);
      }else{
        applyDrag(dx);
      }
    }

    function endDrag(){
      if(!isDown) return;
      isDown = false;

      const dx = currentX - startX;

      if(opened){
        if(dx > 30){
          closeRow();
        }else{
          openRow();
        }
      }else{
        if(dx < -30){
          openRow();
        }else{
          closeRow();
        }
      }
    }

    // Touch
    li.addEventListener('touchstart', e=>{
      startDrag(e.touches[0].clientX);
    }, {passive:true});

    li.addEventListener('touchmove', e=>{
      if(!isDown) return;
      moveDrag(e.touches[0].clientX);
      e.preventDefault();
    }, {passive:false});

    li.addEventListener('touchend', ()=>{
      endDrag();
    });

    // Mouse
    li.addEventListener('mousedown', e=>{
      startDrag(e.clientX);
    });

    li.addEventListener('mousemove', e=>{
      if(!isDown) return;
      moveDrag(e.clientX);
    });

    li.addEventListener('mouseup', ()=>{
      endDrag();
    });

    li.addEventListener('mouseleave', ()=>{
      if(isDown){
        endDrag();
      }
    });

    inner.addEventListener('click', e=>{
      if(li.classList.contains('show-del')){
        e.preventDefault();
        e.stopPropagation();
        closeRow();
      }
    });
  });

  document.querySelectorAll('.del-btn').forEach(btn=>{
    btn.onclick = (e)=>{
      e.stopPropagation();
      const id = Number(btn.dataset.id);
      setTasks(getTasks().filter(t=>t.id!==id));
      render('tasks');
    };
  });
}

/* ==============================
   VIEW FUNCTIONS
============================== */
const view = document.getElementById('view');
const tabsBar = document.getElementById('tabsBar');
let settingsUnlocked=false;
let daySyncTimer=null;
let daySyncVisHandler=null;
let isRolloverRunning=false;

function ensureSettingsAuth(){
  if(settingsUnlocked) return true;
  const pass=prompt('Nhập mật khẩu Settings:');
  if(pass===CONFIG.SETTINGS_PASS){
    settingsUnlocked=true;
    return true;
  }
  alert('Sai mật khẩu');
  return false;
}

/* Build tabs bar */
function buildTabsBar(active){
  tabsBar.innerHTML = [
    {id:'tasks', label:'Tasks', icon:'✅'},
    {id:'leaderboard', label:'Leaderboard', icon:'🏆'},
    {id:'stats', label:'Biểu đồ', icon:'📈'},
    {id:'settings', label:'Settings', icon:'⚙️'}
  ].map(t=>`
    <button class="tab-btn ${t.id===active?'active':''}" data-tab="${t.id}" aria-label="${t.label}" title="${t.label}">
      ${t.icon}
    </button>
  `).join('');

  [...tabsBar.querySelectorAll('.tab-btn')].forEach(btn=>{
    btn.onclick=()=>{
      render(btn.dataset.tab);
    };
  });
}

/* TASKS */

function viewTasks(){
  spawnRecurringIfNeeded();

  const zones=getZones();
  const tasks=getTasks();
  const dateNowDM = todayDM();
  const zoneMap = new Map(zones.map(z=>[z.id,z]));

  const groups = zones.map(z=>{
    const list = tasks
      .filter(t=>t.zoneId==z.id)
      .sort((a,b)=>{
        if(a.kind===b.kind) return Number(a.done)-Number(b.done);
        return a.kind==='recurring' ? -1 : 1;
      });
    const activeList = list.filter(isTaskActiveToday);
    const activeDone = activeList.filter(t=>t.done).length;
    return {
      z,
      list,
      activeList,
      activeDone,
      activeTotal: activeList.length,
      kindLabel: ZONE_KIND_LABELS[z.kind] || 'Zone',
      progressText: activeList.length ? `${activeDone}/${activeList.length}` : '0'
    };
  });

  view.innerHTML = `
    <div class="top">
      <span class="pill">Ngày: <b>${dateNowDM}</b></span>
    </div>

    <div class="creator">
      <input id="taskText" placeholder="Thêm nhiệm vụ… (Enter)">
      <select id="taskZone">${zones.map(z=>`<option value="${z.id}">${z.name}</option>`).join('')}</select>
      <button class="btn-primary" id="btnAdd">Thêm</button>
    </div>

    ${groups.map(g=>{
      const z=g.z;
      const headerClass = z.bg ? 'imgHead' : '';
      const headerStyle = z.bg
        ? `background-image:linear-gradient(0deg,rgba(0,0,0,.5),rgba(0,0,0,.15)),url('${z.bg}');`
        : '';
      return `
      <section class="zone">
        <header class="${headerClass}" style="${headerStyle}">
          <div><b>${z.name}</b> <span class="badge">${g.kindLabel}</span></div>
          <div class="badge">Hoàn thành hôm nay: ${g.progressText}</div>
        </header>
        <ul>
          ${g.list.length? g.list.map(t=>{
            const scoreVal = Number(t.aiScore);
            const hasScore = Number.isFinite(scoreVal);
            const scoreClass = hasScore ? (scoreVal>=0?'positive':'negative') : 'pending';
            const scoreText = hasScore ? formatSignedNumber(scoreVal) : '…';
            const isShared = z.kind==='shared';
            return `
            <li class="task ${t.done?'done':''}" data-id="${t.id}" data-kind="${t.kind||'single'}">
              <div class="task-inner">
                <div class="left">
                  <input type="checkbox" data-id="${t.id}" ${t.done?'checked':''} ${isShared?'disabled':''}>
                  <span class="txt">${t.text}</span>
                  ${renderTaskKindBadge(t)}
                </div>
                <div class="task-actions">
                  <span class="task-score ${scoreClass}">${scoreText}</span>
                  ${isShared?`<button class="assign-btn" data-id="${t.id}" title="Thêm vào Zone Quan trọng">+</button>`:''}
                </div>
              </div>
              <button class="del-btn" data-id="${t.id}">×</button>
            </li>`;
          }).join('') : `<li class="task"><div class="task-inner"><span class="muted">Chưa có task trong Zone này.</span></div></li>`}
        </ul>
      </section>`;
    }).join('')}
  `;

  const inp = document.getElementById('taskText');
  const sel = document.getElementById('taskZone');

  async function addNow(){
    const text=(inp.value||'').trim(); if(!text) return;
    const zoneId = Number(sel.value);
    const z = zones.find(zone=>zone.id==zoneId);
    if(!z) return;

    const currentTasks = getTasks();
    if(z.kind==='zone-e'){
      const activeInZone = getZoneActiveTasks(currentTasks, z.id);
      if(activeInZone.length>=5){
        alert('Zone E chỉ cho phép tối đa 5 task trong ngày.');
        return;
      }
    }

    const newTasks = [...currentTasks];
    let newTask=null;
    if(DAILY_ZONE_KINDS.has(z.kind)){
      const recs = getRecurring();
      const existingRec = recs.find(r=>r.zoneId==z.id && r.type==='daily' && (r.text||'')===text);
      const rec = existingRec || addRecurring({
        text,
        zoneId:z.id,
        type:'daily',
        autoKind:z.kind
      });
      const duplicate = newTasks.some(t=>t.zoneId==z.id && t.kind==='recurring' && t.recurringId===rec.id);
      if(duplicate){
        alert('Task đã tồn tại trong Zone này.');
        return;
      }
      newTask={
        id:Date.now()+Math.random(),
        text,
        zoneId:z.id,
        done:false,
        kind:'recurring',
        recurringId:rec.id
      };
      newTasks.push(newTask);
    } else {
      newTask={
        id:Date.now()+Math.random(),
        text,
        zoneId:z.id,
        done:false,
        kind:'single'
      };
      newTasks.push(newTask);
    }

    await ensureTaskScore(newTask, z);
    setTasks(newTasks);
    inp.value='';
    render('tasks');
  }

  const handleAdd = ()=>{ addNow().catch(err=>console.error(err)); };

  document.getElementById('btnAdd').onclick=handleAdd;
  inp.onkeydown=(e)=>{ if(e.key==='Enter') handleAdd(); };

  window.onkeydown=(e)=>{
    const tag=(document.activeElement?.tagName||'').toLowerCase();
    if(e.key==='Tab' && !['input','select','textarea','button'].includes(tag)){
      e.preventDefault();
      inp.focus();
    }
  };

  view.querySelectorAll('input[type="checkbox"]').forEach(cb=>{
    cb.onchange=async()=>{
      const id=Number(cb.dataset.id);
      const list = getTasks();
      const task = list.find(t=>t.id===id);
      if(!task){
        render('tasks');
        return;
      }
      const zone = zoneMap.get(task.zoneId) || zones.find(z=>z.id==task.zoneId);
      await ensureTaskScore(task, zone);
      const scoreVal = Number(task.aiScore)||0;
      task.done = cb.checked;
      if(scoreVal!==0){
        applyScoreDelta(cb.checked ? scoreVal : -scoreVal, {zoneKind: zone?.kind});
      }
      setTasks(list);
      render('tasks');
    };
  });

  const adoptButtons = view.querySelectorAll('.assign-btn');
  if(adoptButtons.length){
    adoptButtons.forEach(btn=>{
      btn.onclick=async(e)=>{
        e.preventDefault();
        const id=Number(btn.dataset.id);
        const importantZone = zones.find(z=>z.kind==='priority');
        if(!importantZone){
          alert('Chưa cấu hình Zone Quan trọng.');
          return;
        }
        const allTasks = getTasks();
        const source = allTasks.find(t=>t.id===id);
        if(!source){
          render('tasks');
          return;
        }
        const exists = allTasks.some(t=>t.zoneId===importantZone.id && (t.text||'')===(source.text||''));
        if(exists){
          alert('Task đã có trong Zone Quan trọng.');
          return;
        }
        const newTask={
          id:Date.now()+Math.random(),
          text:source.text,
          zoneId:importantZone.id,
          done:false,
          kind:'single',
          aiScore: Number.isFinite(Number(source.aiScore)) ? Number(source.aiScore) : undefined
        };
        await ensureTaskScore(newTask, importantZone);
        allTasks.push(newTask);
        setTasks(allTasks);
        render('tasks');
      };
    });
  }

  attachSwipeHandlersForTasks();

  const pendingIds = tasks.filter(t=>typeof t.aiScore!=='number').map(t=>t.id);
  if(pendingIds.length){
    (async()=>{
      const latestTasks = getTasks();
      const latestZones = getZones();
      const latestZoneMap = new Map(latestZones.map(z=>[z.id,z]));
      let changed=false;
      for(const id of pendingIds){
        const task = latestTasks.find(t=>t.id===id);
        if(!task) continue;
        const zone = latestZoneMap.get(task.zoneId);
        const score = await ensureTaskScore(task, zone);
        if(Number.isFinite(score) && task.aiScore!==score){
          task.aiScore = score;
          changed=true;
        }
      }
      if(changed){
        setTasks(latestTasks);
        if(currentTab==='tasks'){
          viewTasks();
        }
      }
    })();
  }
}

/* LEADERBOARD */
function viewLeaderboard(){
  const cache = getLBCache();

  view.innerHTML = `
    <div class="card" style="margin-top:0">
      <h3>Leaderboard</h3>
      <div class="muted">
        Dữ liệu được tải nền khi mở app. Nhấn "Tải lại" để cập nhật.
      </div>
      <div style="margin:10px 0;display:flex;gap:8px;flex-wrap:wrap">
        <button class="btn-ghost" id="reload">Tải lại</button>
      </div>
      <div class="table-wrap">
        <table id="tbl">
          <thead>
            <tr>
              <th>#</th><th>Người chơi</th><th>Level</th><th>E</th><th>Cập nhật</th>
            </tr>
          </thead>
          <tbody id="rows"></tbody>
        </table>
      </div>
    </div>
  `;

  const rows = document.getElementById('rows');

  function fallbackLocalProfileList(){
    const p=getProfile();
    return [{
      name:p.name||'Player',
      level:p.level||1,
      xp:p.xp||0,
      updatedAt:new Date().toISOString()
    }];
  }

  renderLBRows(rows, cache.list.length ? cache.list : fallbackLocalProfileList());

  document.getElementById('reload').onclick = async ()=>{
    await fetchLeaderboardAndCache();
    const fresh = getLBCache();
    renderLBRows(rows, fresh.list.length ? fresh.list : fallbackLocalProfileList());
  };
}

/* STATS */
function viewStats(){
  const hist = getHist();
  const last7  = hist.slice(-7 ).map(r=>r.xp);
  const last30 = hist.slice(-30).map(r=>r.xp);

  view.innerHTML = `
    <div class="card chart-card" style="margin-top:0">
      <h3>Biểu đồ 7 ngày (E)</h3>
      <canvas id="chart7"></canvas>
    </div>

    <div class="card chart-card">
      <h3>Biểu đồ 30 ngày (E)</h3>
      <canvas id="chart30"></canvas>
    </div>

    <div class="muted" style="margin-top:12px;font-size:13px">
      Lịch sử được lưu mỗi lần bạn bấm "Qua ngày".
    </div>
  `;

  drawChart("chart7", last7);
  drawChart("chart30", last30);
}

/* SETTINGS */
function viewSettings(){
  const p=getProfile();
  const zones=getZones();
  const recs=getRecurring();
  const {level,xp,need}=getLevelInfo();
  const dateNowDM=todayDM();
  const pointRules=getPointRules();
  const defaultRules=DEFAULT_POINT_RULES;
  const zoneDefault=pointRules.zoneCompletion?.default ?? pointRules.zoneCompletion?.regular ?? defaultRules.zoneCompletion.default;
  const zonePriority=pointRules.zoneCompletion?.priority ?? zoneDefault;
  const zoneRegular=pointRules.zoneCompletion?.regular ?? zoneDefault;
  const zoneE=pointRules.zoneCompletion?.['zone-e'] ?? defaultRules.zoneCompletion['zone-e'];
  const zoneNoise=pointRules.zoneCompletion?.noise ?? defaultRules.zoneCompletion.noise;
  const zoneShared=pointRules.zoneCompletion?.shared ?? defaultRules.zoneCompletion.shared;
  const rewardCompleted=pointRules.rollover?.rewardPerCompleted ?? defaultRules.rollover.rewardPerCompleted;
  const penaltyIncomplete=pointRules.rollover?.penaltyPerIncomplete ?? defaultRules.rollover.penaltyPerIncomplete;
  const defaultZoneDefault=defaultRules.zoneCompletion?.default ?? 1;
  const defaultZoneE=defaultRules.zoneCompletion?.['zone-e'] ?? defaultZoneDefault;
  const defaultZoneNoise=defaultRules.zoneCompletion?.noise ?? -1;
  const defaultZoneShared=defaultRules.zoneCompletion?.shared ?? 0;
  const defaultReward=defaultRules.rollover?.rewardPerCompleted ?? 0;
  const defaultPenalty=defaultRules.rollover?.penaltyPerIncomplete ?? 0;

  view.innerHTML = `
    <div class="card" style="margin-top:0">
      <h3>Ngày & Điểm</h3>
      <div class="row">
        <div>Thông tin hiện tại</div>
        <div class="grid" style="grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:8px">
          <div class="pill">Ngày: <b>${dateNowDM}</b></div>
          <div class="pill">Level: <b>${level}</b></div>
          <div class="pill">E: <b>${xp}</b>${need?` / ${need}`:''}</div>
        </div>
      </div>
      <div class="bar"><div class="fill" style="width:${need?Math.min(100,Math.round(xp/need*100)):100}%;"></div></div>

      <div class="row">
        <div>Hành động</div>
        <div class="grid" style="grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:8px">
          <button class="btn-ghost" id="btnEnd">Qua ngày</button>
          <button class="btn-danger" id="btnReset">Reset điểm</button>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Quy tắc điểm thưởng/phạt</h3>
      <div class="muted" style="font-size:13px;margin-bottom:12px">
        <div><b>Mặc định</b></div>
        <ul style="margin:6px 0 0 18px;padding:0;line-height:1.45">
          <li>Zone E: ${formatSignedNumber(defaultZoneE)} E</li>
          <li>Zone Quan trọng / Zone Thường: ${formatSignedNumber(defaultZoneDefault)} E</li>
          <li>Zone Noise: ${formatSignedNumber(defaultZoneNoise)} E</li>
          <li>Zone Giao việc: ${formatSignedNumber(defaultZoneShared)} E</li>
          <li>Qua ngày - mỗi task daily hoàn thành: ${formatSignedNumber(defaultReward)} E</li>
          <li>Qua ngày - mỗi task daily chưa hoàn thành: ${formatSignedNumber(defaultPenalty)} E</li>
        </ul>
      </div>
      <div class="muted" style="font-size:13px;margin-bottom:12px">
        <div><b>Đang áp dụng</b></div>
        <ul style="margin:6px 0 0 18px;padding:0;line-height:1.45">
          <li>Zone E: ${formatSignedNumber(zoneE)} E</li>
          <li>Zone Quan trọng: ${formatSignedNumber(zonePriority)} E</li>
          <li>Zone Thường: ${formatSignedNumber(zoneRegular)} E</li>
          <li>Zone Noise: ${formatSignedNumber(zoneNoise)} E</li>
          <li>Zone Giao việc: ${formatSignedNumber(zoneShared)} E</li>
          <li>Qua ngày (task daily hoàn thành): ${formatSignedNumber(rewardCompleted)} E</li>
          <li>Qua ngày (task daily chưa hoàn thành): ${formatSignedNumber(penaltyIncomplete)} E</li>
        </ul>
      </div>
      <div class="muted" style="font-size:12px;margin-bottom:12px">Nhập số âm nếu muốn trừ điểm.</div>
      <div class="row"><div>Task Zone E</div><input id="ruleZoneE" type="number" step="0.1" inputmode="decimal" value="${zoneE}"></div>
      <div class="row"><div>Task Zone Quan trọng</div><input id="ruleZonePriority" type="number" step="0.1" inputmode="decimal" value="${zonePriority}"></div>
      <div class="row"><div>Task Zone Thường</div><input id="ruleZoneDefault" type="number" step="0.1" inputmode="decimal" value="${zoneRegular}"></div>
      <div class="row"><div>Task Zone Noise</div><input id="ruleZoneNoise" type="number" step="0.1" inputmode="decimal" value="${zoneNoise}"></div>
      <div class="row"><div>Task Zone Giao việc</div><input id="ruleZoneShared" type="number" step="0.1" inputmode="decimal" value="${zoneShared}"></div>
      <div class="row"><div>Qua ngày - thưởng mỗi task daily hoàn thành</div><input id="ruleDailyReward" type="number" step="0.1" inputmode="decimal" value="${rewardCompleted}"></div>
      <div class="row"><div>Qua ngày - phạt mỗi task daily chưa hoàn thành</div><input id="ruleDailyPenalty" type="number" step="0.1" inputmode="decimal" value="${penaltyIncomplete}"></div>
      <div class="row"><div></div><button class="btn-primary" id="savePointRules">Lưu quy tắc</button></div>
    </div>

    <div class="card">
      <h3>Hồ sơ người chơi</h3>
      <div class="row">
        <div>Tên người chơi</div>
        <div class="grid" style="grid-template-columns:1fr auto;align-items:center">
          <input id="name" value="${p.name||''}">
          <button class="btn-primary" id="saveName">Lưu</button>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Zones</h3>
      <div class="grid">
        <div class="row"><div>Tên Zone</div><input id="zName" placeholder="Công việc"></div>
        <div class="row"><div>Loại Zone</div>
          <select id="zKind">${renderZoneKindOptions('regular')}</select>
        </div>
        <div class="row"><div>Hình nền Zone</div>
          <input id="zBg" type="file" accept="image/*">
        </div>
        <div class="row"><div></div><button class="btn-primary" id="addZone">+ Thêm Zone</button></div>
      </div>

      <div class="table-wrap" style="margin-top:12px">
        <table>
          <thead>
            <tr>
              <th>Tên</th>
              <th>Loại</th>
              <th>Nền</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="zoneT">
            ${zones.map(z=>`
              <tr data-id="${z.id}">
                <td><input name="name" value="${z.name}"></td>
                <td>
                  <select name="kind">${renderZoneKindOptions(z.kind)}</select>
                </td>
                <td>
                  <div class="thumb" style="background-image:url('${z.bg||''}')"></div>
                  <input class="bgUpload" data-id="${z.id}" type="file" accept="image/*" style="margin-top:6px">
                </td>
                <td><button class="btn-danger zdel" data-id="${z.id}">Xoá</button></td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3>Tasks lặp (Daily / Weekly)</h3>
      <div class="row"><div>Mô tả</div><input id="rText" placeholder="Tập thể dục 15’"></div>
      <div class="row"><div>Zone</div>
        <select id="rZone">
          ${zones.map(z=>`<option value="${z.id}">${z.name}</option>`).join('')}
        </select>
      </div>
      <div class="row"><div>Kiểu</div>
        <select id="rType">
          <option value="daily">Mỗi ngày</option>
          <option value="weekly">Theo thứ</option>
        </select>
      </div>
      <div class="row" id="rDaysRow" style="display:none">
        <div>Chọn thứ</div>
        <div class="grid" style="grid-template-columns:repeat(7, minmax(40px,1fr));gap:4px;font-size:14px">
          ${['CN','T2','T3','T4','T5','T6','T7'].map((l,i)=>`
            <label style="display:flex;align-items:center;gap:4px">
              <input type="checkbox" value="${i}"> ${l}
            </label>
          `).join('')}
        </div>
      </div>
      <div class="row">
        <div></div>
        <button class="btn-primary" id="addRec">+ Thêm Task lặp</button>
      </div>

      <div class="table-wrap" style="margin-top:12px">
        <table>
          <thead>
            <tr>
              <th>Mô tả</th><th>Zone</th><th>Kiểu</th><th>Thứ</th><th></th>
            </tr>
          </thead>
          <tbody id="recT">
            ${recs.map(r=>{
              const zn = zones.find(z=>z.id==r.zoneId)?.name||'(xoá)';
              return `
                <tr>
                  <td>${r.text}</td>
                  <td>${zn}</td>
                  <td>${r.type}</td>
                  <td>${r.type==='weekly'?(r.days||[]).join(', '):'-'}</td>
                  <td><button class="btn-danger rdel" data-id="${r.id}">Xoá</button></td>
                </tr>`;
            }).join('')}
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3>Quản trị / Dữ liệu cục bộ</h3>
      <div class="row">
        <div>Xoá hồ sơ người chơi LOCAL (máy này)</div>
        <div><button class="btn-danger" id="wipeLocalBtn">Xoá hồ sơ local</button></div>
      </div>
    </div>
  `;

  // helper đọc file => base64
  function readFileAsDataURL(file, cb){
    const reader=new FileReader();
    reader.onload=()=>cb(reader.result);
    reader.readAsDataURL(file);
  }

  /* Ngày & Điểm buttons */
  document.getElementById('btnEnd').onclick = ()=>{ handleEndDay(); };
  document.getElementById('btnReset').onclick = ()=>{ handleResetPoints(); };

  /* Quy tắc điểm */
  const savePointRulesBtn=document.getElementById('savePointRules');
  if(savePointRulesBtn){
    savePointRulesBtn.onclick=()=>{
      const zoneEEl=document.getElementById('ruleZoneE');
      const zonePriorityEl=document.getElementById('ruleZonePriority');
      const zoneDefaultEl=document.getElementById('ruleZoneDefault');
      const zoneNoiseEl=document.getElementById('ruleZoneNoise');
      const zoneSharedEl=document.getElementById('ruleZoneShared');
      const rewardEl=document.getElementById('ruleDailyReward');
      const penaltyEl=document.getElementById('ruleDailyPenalty');
      const entries=[
        {el:zoneEEl, value:Number(zoneEEl.value), label:'Điểm task Zone E'},
        {el:zonePriorityEl, value:Number(zonePriorityEl.value), label:'Điểm task Zone Quan trọng'},
        {el:zoneDefaultEl, value:Number(zoneDefaultEl.value), label:'Điểm task Zone Thường'},
        {el:zoneNoiseEl, value:Number(zoneNoiseEl.value), label:'Điểm task Zone Noise'},
        {el:zoneSharedEl, value:Number(zoneSharedEl.value), label:'Điểm task Zone Giao việc'},
        {el:rewardEl, value:Number(rewardEl.value), label:'Thưởng qua ngày cho task daily hoàn thành'},
        {el:penaltyEl, value:Number(penaltyEl.value), label:'Phạt qua ngày cho task daily chưa hoàn thành'}
      ];
      for(const item of entries){
        if(!Number.isFinite(item.value)){
          alert(`Giá trị không hợp lệ: ${item.label}`);
          item.el.focus();
          return;
        }
      }

      const current=getPointRules();
      setPointRules({
        zoneCompletion:{
          ...current.zoneCompletion,
          default:entries[2].value,
          regular:entries[2].value,
          priority:entries[1].value,
          'zone-e':entries[0].value,
          noise:entries[3].value,
          shared:entries[4].value
        },
        rollover:{
          ...current.rollover,
          rewardPerCompleted:entries[5].value,
          penaltyPerIncomplete:entries[6].value
        }
      });

      alert('Đã cập nhật quy tắc điểm.');
      renderHero();
      render('settings');
    };
  }

  /* Hồ sơ người chơi */
  document.getElementById('saveName').onclick=()=>{
    setName(document.getElementById('name').value);
    alert('Đã lưu');
  };

  /* Zone thêm mới */
  document.getElementById('addZone').onclick=()=>{
    const nameInp=document.getElementById('zName');
    const kindSel=document.getElementById('zKind');
    const nameVal=nameInp.value.trim();
    if(!nameVal){ alert('Nhập tên Zone'); return; }

    const file=document.getElementById('zBg').files[0];
    const kindVal=kindSel.value;

    function finishAdd(bgData){
      const z={
        name:nameVal,
        kind:kindVal,
        bg:bgData||''
      };
      addZone(z);
      nameInp.value='';
      kindSel.value='regular';
      document.getElementById('zBg').value='';
      viewSettings();
    }

    if(file){
      readFileAsDataURL(file, data=>finishAdd(data));
    }else{
      finishAdd('');
    }
  };

  /* Zone chỉnh sửa */
  const zoneTable=document.getElementById('zoneT');
  const handleZoneChange=(e)=>{
    const tr=e.target.closest('tr[data-id]'); if(!tr) return;
    const id=Number(tr.dataset.id);
    const name=e.target.name;
    if(!name) return;
    const val=e.target.value;
    updZone(id,{[name]:val});
  };
  zoneTable.oninput=handleZoneChange;
  zoneTable.onchange=handleZoneChange;

  /* Zone đổi hình nền */
  document.querySelectorAll('.bgUpload').forEach(inp=>{
    inp.onchange=()=>{
      const file=inp.files[0];
      const id=Number(inp.dataset.id);
      if(!file) return;
      readFileAsDataURL(file, data=>{
        updZone(id,{bg:data});
        viewSettings();
      });
    };
  });

  /* Zone xoá */
  document.querySelectorAll('.zdel').forEach(b=> b.onclick=()=>{
    delZone(Number(b.dataset.id));
    viewSettings();
  });

  /* Recurring */
  const typeSel=document.getElementById('rType');
  const daysRow=document.getElementById('rDaysRow');
  typeSel.onchange=()=>{
    daysRow.style.display = typeSel.value==='weekly'?'grid':'none';
  };

  document.getElementById('addRec').onclick=()=>{
    const text=document.getElementById('rText').value.trim();
    if(!text){ alert('Nhập mô tả'); return; }
    const zoneId=Number(document.getElementById('rZone').value);
    const type=typeSel.value;
    const days=[...daysRow.querySelectorAll('input:checked')].map(c=>Number(c.value));
    if(type==='weekly' && !days.length){
      alert('Chọn thứ');
      return;
    }
    addRecurring({text, zoneId, type, days});
    viewSettings();
  };

  document.querySelectorAll('.rdel').forEach(b=> b.onclick=()=>{
    delRecurring(Number(b.dataset.id));
    viewSettings();
  });

  /* Local wipe */
  document.getElementById('wipeLocalBtn').onclick = ()=>{
    if(confirm('Xoá hồ sơ local và cache leaderboard trên máy này?')){
      wipeLocalPlayer();
    }
  };
}

/* ==============================
   ROUTER
============================== */
let currentTab='tasks';

function render(tab){
  currentTab = tab;
  renderHero();
  buildTabsBar(tab);

  if(tab==='tasks'){
    stopDaySyncMonitoring();
    syncDayWithCalendar();
    viewTasks();
    startDaySyncMonitoring();
    return;
  }

  stopDaySyncMonitoring();

  if(tab==='leaderboard'){
    viewLeaderboard();
  } else if(tab==='stats'){
    viewStats();
  } else if(tab==='settings'){
    if(ensureSettingsAuth()){
      viewSettings();
    } else {
      render('tasks');
    }
  } else {
    render('tasks');
  }
}

/* ==============================
   BOOT
============================== */
ensureName();
render('tasks');
backgroundBoardRefresh();
</script>
</body>
</html>
