<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title data-app="document-title">Todo Quest</title>
<style>
:root{
  --ink:#1b1e2e;
  --muted:#7d82a8;
  --tap:46px;
  --radius-card:16px;
  --radius-pill:999px;
  --gradient-main:linear-gradient(135deg,#8b7cff 0%,#b09bff 100%);
  --panel-bg:rgba(255,255,255,.85);
  --panel-border:rgba(0,0,0,.05);
  --panel-shadow:0 16px 40px rgba(0,0,0,.1);
  --glass-bg:rgba(255,255,255,.08);
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  color:var(--ink);
  font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
  background:#f6f7ff;
  background-attachment:fixed;
}

.wrap{
  max-width:960px;
  margin:12px auto;
  padding:20px;
}

h1{
  margin:0 0 12px;
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  gap:4px
}

h1 .app-title{
  font-size:24px;
  font-weight:600;
  color:#1b1e2e;
}

h1 .app-version{
  font-size:14px;
  font-weight:500;
  color:var(--muted);
}

/* Hero */
.hero{
  position:relative;
  border-radius:24px;
  background:var(--gradient-main);
  background-size:cover;
  background-position:center;
  color:#fff;
  overflow:hidden;
  margin-bottom:20px;
  box-shadow:0 24px 48px rgba(139,124,255,.35);
}
.hero::before{
  content:"";
  position:absolute;
  inset:0;
  background:linear-gradient(135deg,rgba(10,14,39,.55),rgba(10,14,39,.25));
}
.hero-inner{
  position:relative;
  z-index:1;
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  gap:20px;
  padding:28px;
  text-align:left;
}
.hero-info{flex:1;min-width:0}
.hero-name{
  margin:0;
  font-size:26px;
  font-weight:700;
  letter-spacing:.4px;
}
.hero-meta{
  margin-top:8px;
  display:flex;
  flex-wrap:wrap;
  gap:12px;
  font-size:16px;
  font-weight:500;
}
.hero-meta span{display:inline-flex;align-items:center;gap:6px}
.hero-progress{margin-top:18px;width:100%}
.hero-progress-bar{
  height:10px;
  background:rgba(255,255,255,.35);
  border-radius:999px;
  overflow:hidden;
}
.hero-progress-fill{
  height:100%;
  width:0;
  background:rgba(255,255,255,.95);
  box-shadow:0 6px 18px rgba(255,255,255,.35);
  border-radius:999px;
}
.hero-progress-label{
  margin-top:8px;
  font-size:14px;
  letter-spacing:.2px;
  opacity:.9;
}

/* Tabs bar */
.tabs{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin-bottom:16px;
  overflow-x:auto;
  padding-bottom:4px;
}
.tabs::-webkit-scrollbar{height:6px}
.tabs::-webkit-scrollbar-thumb{background:#ddd;border-radius:6px}

.tab-btn{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:var(--tap);
  padding:8px 14px;
  border:1px solid var(--panel-border);
  background:rgba(255,255,255,.8);
  border-radius:12px;
  cursor:pointer;
  white-space:nowrap;
  font-weight:500;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
  color:#1b1e2e;
  font-size:18px;
}
.tab-btn.active{
  background:var(--gradient-main);
  color:#fff;
  border-color:transparent;
  box-shadow:0 10px 20px rgba(139,124,255,.4);
}

/* generic buttons */
.btn-primary{
  min-height:var(--tap);
  background:var(--gradient-main);
  color:#fff;border:none;border-radius:12px;
  padding:10px 14px;font-weight:500;
  cursor:pointer;
  box-shadow:0 10px 20px rgba(139,124,255,.4);
  font-size:14px;
}
.btn-ghost{
  min-height:var(--tap);
  background:rgba(255,255,255,.8);
  border:1px solid var(--panel-border);
  border-radius:12px;
  padding:10px 14px;
  font-size:14px;
  font-weight:500;
  color:#1b1e2e;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
  cursor:pointer;
}
.btn-ghost:active{
  transform:translateY(1px);
  box-shadow:0 4px 12px rgba(0,0,0,.12);
}
.btn-ghost[disabled],
.btn-ghost[data-loading]{
  cursor:progress;
  opacity:.6;
  box-shadow:none;
  transform:none;
}
.btn-danger{
  min-height:var(--tap);
  background:linear-gradient(135deg,#ff5f48 0%,#ff3425 100%);
  color:#fff;border:none;border-radius:12px;
  padding:10px 14px;font-weight:500;
  cursor:pointer;
  box-shadow:0 10px 20px rgba(255,60,48,.4);
  font-size:14px;
}
.btn-primary.btn-sm,
.btn-ghost.btn-sm,
.btn-danger.btn-sm{
  min-height:36px;
  padding:6px 12px;
  font-size:13px;
}

/* pills */
.pill{
  background:rgba(255,255,255,.8);
  border:1px solid var(--panel-border);
  border-radius:var(--radius-pill);
  padding:4px 10px;
  font-size:14px;
  font-weight:500;
  color:#1b1e2e;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
}
.task-points { 
  font-weight: bold; 
  margin-left: 8px; 
  font-size: 14px; 
}
.task-points.positive { color: #16a34a; }
.task-points.negative { color: #dc2626; }
.task-points.neutral { color: #4b5563; }
.task-kind{
  display:inline-flex;
  align-items:center;
  padding:2px 8px;
  margin-left:8px;
  font-size:11px;
  font-weight:600;
  border-radius:999px;
  text-transform:uppercase;
  letter-spacing:.4px;
  background:rgba(139,124,255,.18);
  color:#5a4cc1;
}
.task-kind.single{
  background:rgba(34,197,94,.18);
  color:#1f9d55;
}
.task-kind.recurring{
  background:rgba(59,130,246,.18);
  color:#2563eb;
}
.task-kind.recurring.negative{
  background:rgba(248,113,113,.18);
  color:#dc2626;
}
.task.done .task-kind{opacity:.7}
.muted{color:var(--muted);font-size:14px}
.top{
  display:flex;
  align-items:center;
  gap:8px;
  margin-bottom:12px;
  flex-wrap:wrap
}

/* Inputs */
input,select,textarea{
  height:var(--tap);
  padding:10px;
  border-radius:12px;
  border:1px solid rgba(0,0,0,.08);
  width:100%;
  font:inherit;
  font-size:14px;
  background:#fff;
  box-shadow:0 6px 16px rgba(0,0,0,.05);
}
input[type="checkbox"]{
  height:auto;width:auto;box-shadow:none;
}

/* layout (Settings rows) */
.grid{display:grid;gap:10px}
.row{
  display:grid;
  grid-template-columns:200px 1fr;
  gap:10px;
  align-items:flex-start;
}

.card{
  padding:16px;
  border:1px solid var(--panel-border);
  border-radius:16px;
  background:var(--panel-bg);
  margin-top:16px;
  box-shadow:var(--panel-shadow);
  position:relative;
  overflow:hidden;
}
.card h3{
  margin:0 0 12px;
  font-size:16px;
  font-weight:600;
  color:#1b1e2e;
}

.bar{
  height:10px;
  background:rgba(0,0,0,.07);
  border-radius:6px;
  overflow:hidden;
  margin-bottom:10px;
  box-shadow:inset 0 2px 4px rgba(0,0,0,.12);
}
.fill{
  height:100%;
  background:linear-gradient(90deg,#8b7cff 0%,#b09bff 100%);
}

/* task lists */
ul{list-style:none;margin:0;padding:0}
.archive-toolbar{
  display:flex;
  justify-content:flex-end;
  gap:8px;
  flex-wrap:wrap;
  margin-top:12px;
}
.archive-list{
  display:flex;
  flex-direction:column;
  gap:12px;
  margin:16px 0 0;
}
.archive-item{
  display:flex;
  gap:12px;
  padding:12px;
  border:1px solid var(--panel-border);
  border-radius:12px;
  background:rgba(255,255,255,.8);
  box-shadow:0 6px 16px rgba(0,0,0,.06);
}
.archive-info{flex:1;min-width:0;}
.archive-title{font-weight:600;word-break:break-word;}
.archive-meta{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  margin-top:6px;
  font-size:12px;
  color:var(--muted);
  align-items:center;
}
.archive-meta .sep{color:rgba(0,0,0,.25);}
.archive-reason{
  margin-top:8px;
  font-size:13px;
  color:var(--muted);
  word-break:break-word;
}
.archive-actions{display:flex;align-items:center;gap:8px;}
.archive-empty{
  margin-top:12px;
  color:var(--muted);
}

.zone{
  border:1px solid rgba(0,0,0,.05);
  border-radius:16px;
  margin:16px 0;
  background:rgba(255,255,255,.8);
  box-shadow:0 12px 32px rgba(0,0,0,.08);
  overflow:hidden;
}
.zone header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:12px 16px;
  border-bottom:1px solid rgba(0,0,0,.05);
  background:linear-gradient(135deg,#fafbff 0%,#f6f7ff 100%);
  font-weight:500;
  color:#1b1e2e;
}
.zone header.imgHead{
  color:#fff;
  border-bottom:1px solid rgba(255,255,255,.3);
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  background-blend-mode:normal;
}
.zone header.imgHead .badge{
  background:rgba(0,0,0,.4);
  color:#fff;
  border:1px solid rgba(255,255,255,.3);
}

.badge{
  font-size:12px;
  padding:2px 8px;
  border-radius:var(--radius-pill);
  background:#fff;
  border:1px solid rgba(0,0,0,.07);
  color:#1b1e2e;
  font-weight:500;
  box-shadow:0 4px 10px rgba(0,0,0,.08);
}

/* swipe task row */
li.task{
  position:relative;
  border-top:1px solid rgba(0,0,0,.03);
  background:transparent;
  padding:0;
  overflow:hidden;
}
.task-inner{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:12px 16px;
  background:transparent;
  transition:transform .2s;
}
.left{display:flex;align-items:center;gap:10px}
.done .txt{text-decoration:line-through;color:#9aa}
.creator{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0}
.left input[type="checkbox"]{transform:scale(1.25)}

.del-btn{
  position:absolute;
  right:0;
  top:0;
  bottom:0;
  width:60px;
  min-width:60px;
  padding:0;
  border:none;
  border-radius:0;
  background:linear-gradient(135deg,#ff5f48 0%,#ff3425 100%);
  color:#fff;
  font-size:20px;
  font-weight:600;
  line-height:1;
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow:-4px 0 16px rgba(0,0,0,.2);
  transition:transform .2s;
  transform:translateX(60px); /* ẩn ban đầu */
}

li.task.show-del .task-inner{
  transform:translateX(-60px);
}
li.task.show-del .del-btn{
  transform:translateX(0);
}

/* tắt transition khi đang kéo */
li.task.dragging .task-inner{
  transition:none;
}
li.task.dragging .del-btn{
  transition:none;
}

/* Leaderboard table */
.table-wrap{
  overflow:auto;
  border:1px solid rgba(0,0,0,.05);
  border-radius:16px;
  background:rgba(255,255,255,.8);
  box-shadow:0 16px 32px rgba(0,0,0,.08);
}
table{
  width:100%;
  border-collapse:collapse;
  background:transparent;
  font-size:14px;
}
th,td{
  padding:12px 16px;
  border-bottom:1px solid rgba(0,0,0,.05);
  text-align:left;
  white-space:nowrap;
}
th{
  font-weight:600;
  color:#1b1e2e;
  background:rgba(255,255,255,.6)
}

/* Charts */
.chart-card canvas{
  width:100%;
  max-width:100%;
  height:160px;
  display:block;
}

/* thumb preview */
.thumb{
  width:48px;
  height:48px;
  border-radius:10px;
  border:1px solid rgba(0,0,0,.1);
  background-size:cover;
  background-position:center;
  background-color:#eee;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
}

  @media (max-width:768px){
    .row{grid-template-columns:1fr}
    .creator{flex-direction:column}
    h1 .app-title{font-size:20px}
  .hero-inner{gap:18px;padding:22px}
  .hero-name{font-size:22px}
  .hero-meta{font-size:15px}
}
@media (max-width:480px){
  body{font-size:15px}
  .tab-btn{padding:8px 12px}
  .tabs{gap:6px}
}
	.ai-reason{
  font-size:12px;
  color:var(--muted);
  margin-left:28px;   /* canh thẳng hàng với text task */
  margin-top:2px;
}

</style>
</head>
<body>

<div class="wrap">
  <h1>
    <span class="app-title" data-app="title">Todo Quest</span>
    <span class="app-version" data-app="version"></span>
  </h1>

  <section id="hero" class="hero">
    <div class="hero-inner">
      <div class="hero-info">
        <div class="hero-name" data-hero="name">Player</div>
        <div class="hero-meta">
          <span class="hero-level" data-hero="level">Level 1</span>
          <span class="hero-xp" data-hero="xp">0 E</span>
        </div>
        <div class="hero-progress">
          <div class="hero-progress-bar">
            <div class="hero-progress-fill" data-hero="xp-fill"></div>
          </div>
          <div class="hero-progress-label" data-hero="xp-label">0 / 100 E</div>
        </div>
      </div>
    </div>
  </section>

  <div class="tabs" id="tabsBar"></div>

  <div id="view">Đang nạp…</div>
</div>

<script>
/* ==============================
   CONFIG
============================== */
const APP_NAME = 'Todo Quest';

const CONFIG = {
  VERSION:'1.0',
  ENDPOINT:'https://script.google.com/macros/s/AKfycbyQ3imjnhKrzmuz4-KbPNsHzpYGY_Mv45os1bZEPoQrQ-UM8RjJvCznfP5x6RB6QX_Qpw/exec',
  SETTINGS_PASS:'1000',
  HERO_LEVELS:[
    {
      minLevel:1,
      maxLevel:3,
      characterImg:"url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 120\"><circle cx=\"50\" cy=\"38\" r=\"26\" fill=\"%23f97316\"/><rect x=\"22\" y=\"64\" width=\"56\" height=\"44\" rx=\"18\" fill=\"%23fb923c\"/></svg>')",
      backgroundImg:'linear-gradient(135deg,#fde68a 0%,#f97316 100%)'
    },
    {
      minLevel:4,
      maxLevel:6,
      characterImg:"url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 120\"><circle cx=\"50\" cy=\"38\" r=\"26\" fill=\"%232563eb\"/><rect x=\"22\" y=\"64\" width=\"56\" height=\"44\" rx=\"18\" fill=\"%2393c5fd\"/></svg>')",
      backgroundImg:'linear-gradient(135deg,#bae6fd 0%,#2563eb 100%)'
    },
    {
      minLevel:7,
      characterImg:"url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 120\"><circle cx=\"50\" cy=\"38\" r=\"26\" fill=\"%237c3aed\"/><rect x=\"22\" y=\"64\" width=\"56\" height=\"44\" rx=\"18\" fill=\"%23c4b5fd\"/></svg>')",
      backgroundImg:'linear-gradient(135deg,#e9d5ff 0%,#7c3aed 100%)'
    }
  ],
  BACKGROUND_THEME:{
    appDefaultBgUrl:'linear-gradient(160deg,#dfe8ff 0%,#f6f0ff 45%,#ffffff 100%)',
    heroByLevel:[
      {
        minLevel:1,
        maxLevel:3,
        heroBgUrl:'linear-gradient(135deg,#fde68a 0%,#f97316 100%)',
        appBgUrl:'linear-gradient(160deg,#fff6eb 0%,#ffe7d4 45%,#ffd8c2 100%)'
      },
      {
        minLevel:4,
        maxLevel:6,
        heroBgUrl:'linear-gradient(135deg,#bae6fd 0%,#2563eb 100%)',
        appBgUrl:'linear-gradient(160deg,#e1f2ff 0%,#d5e7ff 50%,#f1f6ff 100%)'
      },
      {
        minLevel:7,
        heroBgUrl:'linear-gradient(135deg,#e9d5ff 0%,#7c3aed 100%)',
        appBgUrl:'linear-gradient(160deg,#f0e7ff 0%,#dcd1ff 40%,#f8f4ff 100%)'
      }
    ]
  }
};

window.APP_CONFIG = CONFIG;

const APP_VERSION = CONFIG.VERSION;

(function syncAppMeta(){
  const versionLabel = `v${APP_VERSION}`;
  document.title = `${APP_NAME} – ${versionLabel}`;

  const nameEl = document.querySelector('[data-app="title"]');
  if(nameEl){
    nameEl.textContent = APP_NAME;
  }

  const versionEl = document.querySelector('[data-app="version"]');
  if(versionEl){
    versionEl.textContent = versionLabel;
  }
})();

/* ==============================
   LOCAL STORAGE KEYS
============================== */
const LS = {
  PROFILE:'tq_profile',
  ZONES:'tq_zones',
  TASKS:'tq_tasks',
  RECUR:'tq_recurring',
  DAY:'tq_sim_day',
  BONUS:'tq_bonus_flags',
  SPAWN:'tq_spawned_day',
  LBCACHE:'tq_lb_cache',
  HIST:'tq_hist',
  REALDATE:'tq_real_date',
  ARCHIVE:'tq_archive'
};

function normalizeArchiveEntry(raw){
  if(!raw || typeof raw !== 'object') return null;
  const taskId = raw.taskId != null ? String(raw.taskId) : '';
  if(!taskId) return null;
  const zoneId = raw.zoneId != null ? String(raw.zoneId) : '';
  const completedAt = typeof raw.completedAt === 'string' ? raw.completedAt : '';
  return {
    taskId,
    text: String(raw.text || ''),
    zoneId,
    zoneName: String(raw.zoneName || ''),
    zoneKind: String(raw.zoneKind || ''),
    completedAt,
    points: Number(raw.points) || 0,
    reason: String(raw.reason || '').trim()
  };
}

function getArchive(){
  const raw = load(LS.ARCHIVE, []);
  if(!Array.isArray(raw)) return [];
  return raw.map(normalizeArchiveEntry).filter(Boolean);
}
function setArchive(list){
  if(!Array.isArray(list)) list = [];
  const normalized = list.map(normalizeArchiveEntry).filter(Boolean);
  save(LS.ARCHIVE, normalized);
}

const ZONE_KIND_LABELS = {
  'e':'Zone E',
  'priority':'Zone Quan trọng',
  'noise':'Zone Noise',
  'regular':'Zone Thường'
};
const ZONE_KIND_ORDER = ['e','priority','noise','regular'];
const DEFAULT_ZONES = ZONE_KIND_ORDER.map((kind)=>({
  name: ZONE_KIND_LABELS[kind],
  kind,
  bg:''
}));

const DAILY_ZONE_KINDS = new Set(['e','noise']);
const ARCHIVE_ZONE_KINDS = new Set(['priority','regular']);
let lbTimer = null;


/* ==============================
   HERO ELEMENTS
============================== */
const heroEl = document.getElementById('hero');
const heroRefs = heroEl ? {
  name: heroEl.querySelector('[data-hero="name"]'),
  level: heroEl.querySelector('[data-hero="level"]'),
  xp: heroEl.querySelector('[data-hero="xp"]'),
  xpFill: heroEl.querySelector('[data-hero="xp-fill"]'),
  xpLabel: heroEl.querySelector('[data-hero="xp-label"]')
} : {};

/* ==============================
   LEVEL CONFIG
============================== */
const LEVELS = [
  {lvl:1, need:100},
  {lvl:2, need:250},
  {lvl:3, need:500},
  {lvl:4, need:800},
  {lvl:5, need:1200},
  {lvl:6, need:1700},
  {lvl:7, need:2300},
  {lvl:8, need:3000},
  {lvl:9, need:3800},
];

function calcTotalE(level, xp){
  const lvl = Number(level) || 0;
  const currentXP = Number(xp) || 0;
  let total = currentXP;
  for(const cfg of LEVELS){
    if(cfg.lvl >= lvl) break;
    total += Number(cfg.need) || 0;
  }
  return total;
}

/* ==============================
   GENERIC HELPERS
============================== */
function load(key, def){ try{ return JSON.parse(localStorage.getItem(key)) ?? def }catch{ return def } }
function save(key, val){ localStorage.setItem(key, JSON.stringify(val)) }

function generateProfileId(){
  try {
    if(typeof crypto !== 'undefined'){
      if(typeof crypto.randomUUID === 'function'){
        return crypto.randomUUID();
      }
      if(typeof crypto.getRandomValues === 'function'){
        const arr = new Uint32Array(4);
        crypto.getRandomValues(arr);
        return Array.from(arr).map(n=>n.toString(16).padStart(8,'0')).join('');
      }
    }
  } catch(_err) {
    // ignore and fallback below
  }
  const time = Date.now().toString(36);
  const rand = Math.random().toString(36).slice(2,10);
  return `p-${time}-${rand}`;
}

function formatSignedNumber(n){
  const val = Number(n)||0;
  return `${val>=0?'+':''}${val}`;
}
function todayDM(){
  const d=new Date();
  const dd=String(d.getDate()).padStart(2,'0');
  const mm=String(d.getMonth()+1).padStart(2,'0');
  return `${dd}-${mm}`;
}
function getLastRealDate(){
  return localStorage.getItem(LS.REALDATE) || '';
}
function setLastRealDate(val){
  if(val){
    localStorage.setItem(LS.REALDATE, val);
  }
}
function lastLevelCfg(){ return LEVELS[LEVELS.length-1]; }

/* ==============================
   AI TASK SCORING (FINAL)
============================== */
const AI_ENDPOINT = "https://todo-quest-proxyp260992.vercel.app/api/score"; // sửa đúng URL proxy đang chạy


/**
 * Chấm điểm 1 task và trả về object đầy đủ từ proxy.
 * @param {string} taskText
 * @param {string} zoneKind: 'e' | 'priority' | 'noise' | 'regular'
 * @returns {{zone:string, category:string, points:number, reason:string}}
 */
async function getTaskPoints(taskText, zoneKind) {
  const zoneLabel = ZONE_KIND_LABELS[zoneKind] || "Zone Thường";
  const r = await fetch(AI_ENDPOINT, {
    method: "POST",
    headers: { "Content-Type": "application/json", "X-Scoring-Version": "v2" },
    body: JSON.stringify({ text: taskText, zone: zoneLabel })
  });
  if (!r.ok) return { points: 0, reason: "" };
  const data = await r.json();
  const reason = String(data.reason || "").trim().split(/\s+/).slice(0,10).join(" ");
  return { points: Number(data.points)||0, reason, category: data.category, zone: data.zone };
}

function normalizeAiScoreForZone(ai, zoneKind){
  const basePoints = Number(ai.points);
  const normalized = {
    points: Number.isFinite(basePoints) ? basePoints : 0,
    reason: String(ai.reason || '').trim(),
    category: ai.category,
    zone: ai.zone
  };

  if(zoneKind === 'noise'){
    const initialPoints = Number.isFinite(basePoints) ? basePoints : 0;
    let nextPoints = initialPoints;
    if(nextPoints > -1){
      nextPoints = -1;
    }
    if(nextPoints === 0){
      nextPoints = -1;
    }

    const segments = [];
    const addSegment = (part) => {
      const trimmed = String(part || '').trim();
      if(!trimmed) return;
      const lower = trimmed.toLowerCase();
      if(!segments.some(seg => seg.toLowerCase() === lower)){
        segments.push(trimmed);
      }
    };

    if(initialPoints >= 0){
      addSegment('Nhầm Zone');
    }

    normalized.reason.split(/—| - /).forEach(addSegment);

    normalized.points = nextPoints;
    normalized.reason = segments.join(' — ');
  }

  return normalized;
}

/* ==============================
   PROFILE / LEVEL / XP ("E")
============================== */
function getProfile(){
  let p = load(LS.PROFILE);
  let changed = false;

  if(!p || typeof p !== 'object' || Array.isArray(p)){
    p = { id: generateProfileId(), name:'', level:1, xp:0 };
    changed = true;
  } else {
    if(!p.id){
      p.id = generateProfileId();
      changed = true;
    }
    if(typeof p.name !== 'string'){
      p.name = '';
      changed = true;
    }
    const lvl = Number(p.level);
    if(!Number.isFinite(lvl) || lvl < 1){
      p.level = 1;
      changed = true;
    } else if(typeof p.level !== 'number'){
      p.level = lvl;
      changed = true;
    }
    const xpVal = Number(p.xp);
    if(!Number.isFinite(xpVal) || xpVal < 0){
      p.xp = 0;
      changed = true;
    } else if(typeof p.xp !== 'number'){
      p.xp = xpVal;
      changed = true;
    }
  }

  if(changed){
    save(LS.PROFILE, p);
  }
  return p;
}
function setName(name){
  const p=getProfile(); p.name=(name||'').trim(); save(LS.PROFILE,p);
  renderHero();
}
function addXP(delta){
  const p=getProfile();
  p.xp = Math.max(0, Number(p.xp||0)+Number(delta||0));
  while(true){
    const cfg = LEVELS.find(x=>x.lvl===p.level) || lastLevelCfg();
    const need = cfg.need || 0;
    if(need>0 && p.xp>=need){
      p.xp -= need;
      const maxLvl = lastLevelCfg().lvl;
      p.level = Math.min(maxLvl, p.level+1);
    } else {
      break;
    }
  }
  save(LS.PROFILE,p);
  scheduleAutoSync();
  renderHero();
}
function getLevelInfo(){
  const p=getProfile();
  const cfg = LEVELS.find(x=>x.lvl===p.level) || lastLevelCfg();
  return {level:p.level, xp:p.xp, need:cfg.need||0};
}
function resetPoints(){
  const p=getProfile(); p.level=1; p.xp=0; save(LS.PROFILE,p);
  renderHero();
}
function ensureName(){
  const p=getProfile();
  if(!p.name){
    const n=prompt('Nhập tên người chơi:');
    if(n) setName(n);
  }
}

/* ==============================
   HERO RENDERING
============================== */
function pickHeroConfigFor(level){
  const list = Array.isArray(CONFIG.HERO_LEVELS) ? CONFIG.HERO_LEVELS : [];
  const fallback = list[list.length-1] || null;
  for(const item of list){
    if(typeof item.level === 'number' && item.level === level) return item;
    if(Array.isArray(item.levels) && item.levels.includes(level)) return item;
    const min = typeof item.minLevel === 'number' ? item.minLevel : (typeof item.min === 'number' ? item.min : -Infinity);
    const max = typeof item.maxLevel === 'number' ? item.maxLevel : (typeof item.max === 'number' ? item.max : Infinity);
    if(level>=min && level<=max) return item;
  }
  return fallback;
}

function getBackgroundTheme(){
  return CONFIG && typeof CONFIG === 'object' ? (CONFIG.BACKGROUND_THEME || {}) : {};
}

function pickHeroBackgroundThemeFor(level){
  const theme = getBackgroundTheme();
  const list = Array.isArray(theme.heroByLevel) ? theme.heroByLevel : [];
  const fallback = list[list.length-1] || null;
  for(const item of list){
    if(typeof item.level === 'number' && item.level === level) return item;
    if(Array.isArray(item.levels) && item.levels.includes(level)) return item;
    const min = typeof item.minLevel === 'number' ? item.minLevel : (typeof item.min === 'number' ? item.min : -Infinity);
    const max = typeof item.maxLevel === 'number' ? item.maxLevel : (typeof item.max === 'number' ? item.max : Infinity);
    if(level>=min && level<=max) return item;
  }
  return fallback;
}

function normalizeBackgroundValue(raw){
  const result = { image:'', color:'' };
  if(!raw) return result;
  const trimmed = `${raw}`.trim();
  if(!trimmed) return result;
  const lower = trimmed.toLowerCase();
  if(/^(#[0-9a-f]{3,8}|rgba?\(|hsla?\()/i.test(trimmed)){
    result.color = trimmed;
    return result;
  }
  const shouldWrap = !(lower.startsWith('url(') || lower.includes('gradient('));
  result.image = shouldWrap ? `url('${trimmed.replace(/'/g,"\\'")}')` : trimmed;
  return result;
}

function applyBackgroundToElement(el, value, fallbackValue, options){
  if(!el) return;
  const opts = Object.assign({ size:null, position:null, attachment:null, repeat:null }, options);
  const normalized = normalizeBackgroundValue(value);
  const fallbackNormalized = normalizeBackgroundValue(fallbackValue);
  const final = (normalized.image || normalized.color) ? normalized : fallbackNormalized;

  el.style.backgroundImage = final.image || '';
  el.style.backgroundColor = final.color || '';

  if(opts.size !== null){
    el.style.backgroundSize = opts.size;
  }
  if(opts.position !== null){
    el.style.backgroundPosition = opts.position;
  }
  if(opts.attachment !== null){
    el.style.backgroundAttachment = opts.attachment;
  }
  if(opts.repeat !== null){
    el.style.backgroundRepeat = opts.repeat;
  }
}

function renderHero(){
  if(!heroEl) return;

  const profile = getProfile();
  const {level,xp,need} = getLevelInfo();
  const preset = pickHeroConfigFor(level) || {};
  const backgroundTheme = getBackgroundTheme();
  const heroThemePreset = pickHeroBackgroundThemeFor(level) || {};
  const name = (profile.name || '').trim() || 'Player';
  const pct = need ? Math.min(100, Math.round(xp/need*100)) : 100;

  const defaultHeroBg = preset.backgroundImg || 'linear-gradient(135deg,#8b7cff 0%,#b09bff 100%)';
  applyBackgroundToElement(heroEl, heroThemePreset.heroBgUrl, defaultHeroBg, { size:'cover', position:'center' });

  const appBgFallback = backgroundTheme.appDefaultBgUrl || '';
  const appBgValue = heroThemePreset.appBgUrl || '';
  if(appBgValue || appBgFallback){
    applyBackgroundToElement(document.body, appBgValue, appBgFallback, { size:'cover', attachment:'fixed' });
  } else {
    applyBackgroundToElement(document.body, '', '', { size:'', attachment:'fixed' });
  }

  if(heroRefs.name){
    heroRefs.name.textContent = name;
  }
  if(heroRefs.level){
    heroRefs.level.textContent = `Level ${level}`;
  }
  if(heroRefs.xp){
    heroRefs.xp.textContent = `${xp} E`;
  }
  if(heroRefs.xpLabel){
    heroRefs.xpLabel.textContent = need ? `${xp} / ${need} E tới level tiếp theo` : `${xp} E (tối đa)`;
  }
  if(heroRefs.xpFill){
    heroRefs.xpFill.style.width = `${pct}%`;
  }
}

/* ==============================
   HISTORY SNAPSHOT (Stats)
============================== */
function getHist(){ return load(LS.HIST,[]); }
function setHist(h){ save(LS.HIST,h); }
function pushHistSnapshot(){
  const p=getProfile();
  const h=getHist();
  h.push({
    ts:Date.now(),
    level:p.level,
    xp:p.xp
  });
  if(h.length>60){
    h.splice(0, h.length-60);
  }
  setHist(h);
}

/* ==============================
   DAY / FLAGS
============================== */
function getDay(){
  let d=Number(localStorage.getItem(LS.DAY)||0);
  if(!d){ d=1; localStorage.setItem(LS.DAY,d); }
  return d;
}
function nextDay(){
  const d=getDay()+1;
  localStorage.setItem(LS.DAY,d);
  return d;
}
function loadFlags(){ return load(LS.BONUS,{}); }
function saveFlags(f){ save(LS.BONUS,f); }
function bonusGiven(zoneId){
  const day=getDay();
  const f=loadFlags();
  return !!(f[day] && f[day][zoneId]);
}
function markBonus(zoneId){
  const day=getDay();
  const f=loadFlags();
  if(!f[day]) f[day]={};
  f[day][zoneId]=true;
  saveFlags(f);
}
function clearFlagsFor(day){
  const f=loadFlags();
  delete f[day];
  saveFlags(f);
}

/* ==============================
   ZONES / TASKS / RECURRING
============================== */
function normalizeZoneRecord(raw, idx, idBase){
  if(!raw || typeof raw!=='object') return {changed:true, zone:null};
  const zone = {...raw};
  let changed=false;

  if(typeof zone.id!=='number'){
    zone.id = idBase + idx;
    changed=true;
  }

  zone.name = typeof zone.name==='string' ? zone.name.trim() : '';
  if(!zone.name){
    zone.name = `Zone ${idx+1}`;
    changed=true;
  }

  if(zone.kind === 'public'){
    zone.kind = 'regular';
    if(zone.name === 'Zone Giao việc'){
      zone.name = ZONE_KIND_LABELS['regular'];
    }
    changed = true;
  }

  if(typeof zone.bg!=='string'){
    zone.bg='';
    changed=true;
  }

  if(!ZONE_KIND_LABELS[zone.kind]){
    const fallbackKind = DEFAULT_ZONES.find(d=>d.name===zone.name)?.kind || 'regular';
    zone.kind = fallbackKind;
    changed=true;
  }

  return {changed, zone};
}

function getZones(){
  const loaded = load(LS.ZONES, []);
  const idBase = Date.now();
  let zones = [];
  let changed=false;

  if(Array.isArray(loaded) && loaded.length){
    loaded.forEach((item, idx)=>{
      const {changed: rowChanged, zone} = normalizeZoneRecord(item, idx, idBase+idx*10);
      if(rowChanged) changed=true;
      if(zone) zones.push(zone);
    });
  }

  if(!zones.length){
    const base = Date.now();
    zones = DEFAULT_ZONES.map((z, idx)=>({
      id: base + idx,
      name: z.name,
      kind: z.kind,
      bg: z.bg
    }));
    changed=true;
  }

  const existingKinds = new Set(zones.map(z=>z.kind));
  const missingDefaults = DEFAULT_ZONES.filter(def=>!existingKinds.has(def.kind));
  if(missingDefaults.length){
    const base = Date.now();
    missingDefaults.forEach((def, idx)=>{
      zones.push({
        id: base + idx,
        name: def.name,
        kind: def.kind,
        bg: def.bg
      });
    });
    changed=true;
  }

  if(changed){
    setZones(zones);
  }

  return zones;
}
function setZones(z){ save(LS.ZONES,z) }
function sanitizeZoneInput(z){
  return {
    name: typeof z.name==='string' ? z.name.trim() : '',
    kind: ZONE_KIND_LABELS[z.kind] ? z.kind : 'regular',
    bg: typeof z.bg==='string' ? z.bg : ''
  };
}
function renderZoneKindOptions(selected){
  return ZONE_KIND_ORDER.map(kind=>`<option value="${kind}" ${kind===selected?'selected':''}>${ZONE_KIND_LABELS[kind]}</option>`).join('');
}
function addZone(z){
  const list=getZones();
  const clean = sanitizeZoneInput(z);
  clean.id = Date.now() + Math.floor(Math.random()*1000);
  if(!clean.name){
    clean.name = `Zone ${list.length+1}`;
  }
  setZones([...list, clean]);
}
function updZone(id,patch){
  const clean={...patch};
  if('name' in clean){
    clean.name = (clean.name||'').trim();
    if(!clean.name) delete clean.name;
  }
  if('bg' in clean && typeof clean.bg!=='string'){
    delete clean.bg;
  }
  if('kind' in clean){
    clean.kind = ZONE_KIND_LABELS[clean.kind] ? clean.kind : 'regular';
  }
  setZones(getZones().map(z=>z.id===id?{...z,...clean}:z));
}
function delZone(id){
  setZones(getZones().filter(z=>z.id!==id));
}

async function addRecurring(r){
  const rec = {...r};
  rec.id = Date.now() + Math.floor(Math.random()*1000);

  // Lấy zone để biết kind
  const zones = getZones();
  const z = zones.find(z => z.id == rec.zoneId);
  const zoneKind = z ? z.kind : 'regular';

  const ai = await getTaskPoints(rec.text, zoneKind);
  const normalizedAi = normalizeAiScoreForZone(ai, zoneKind);
  rec.points = normalizedAi.points; // lưu điểm base cho recurring
  rec.reason = normalizedAi.reason;

  const list = [...getRecurring(), rec];
  save(LS.RECUR, list);
  return rec;
}

function delRecurring(id){
  save(LS.RECUR,getRecurring().filter(r=>r.id!==id));
}

function getRecurring(){ return load(LS.RECUR,[]) }

function getTasks(){
  const raw = load(LS.TASKS, []);
  if(!Array.isArray(raw)) return [];

  const zones = getZones();
  const zoneKindMap = new Map(zones.map(z=>[Number(z.id), z.kind]));

  let recs = getRecurring();
  let recChanged=false;
  const adjustedRecs = recs.map((r)=>{
    if(!r || typeof r!=='object') return r;
    const zoneKind = zoneKindMap.get(Number(r.zoneId));
    if(zoneKind!=='noise') return r;

    const normalized = normalizeAiScoreForZone({ points: r.points, reason: r.reason }, 'noise');
    const next = { ...r };
    let changedRow = false;
    if(Number(next.points) !== normalized.points){
      next.points = normalized.points;
      changedRow = true;
    }
    const nextReason = normalized.reason;
    if(String(next.reason || '') !== nextReason){
      next.reason = nextReason;
      changedRow = true;
    }
    if(changedRow) recChanged = true;
    return changedRow ? next : r;
  });
  if(recChanged){
    save(LS.RECUR, adjustedRecs);
  }
  recs = adjustedRecs;

  const recIndex = new Map();
  for(const r of recs){
    const key = `${Number(r.zoneId)}|${String(r.text||'')}`;
    if(!recIndex.has(key)) recIndex.set(key, []);
    recIndex.get(key).push(r);
  }

  let changed=false;
  const normalized = raw.map(item=>{
    if(!item || typeof item!=='object'){
      changed=true;
      return null;
    }

    const zoneId = Number(item.zoneId);
    const zoneKind = zoneKindMap.get(zoneId);
    let kind = item.kind==='recurring' ? 'recurring' : (item.kind==='single' ? 'single' : null);
    let recurringId = typeof item.recurringId==='number' ? item.recurringId : null;
    let done = !!item.done;
    let points = Number(item.points) || 0;

    if(kind===null){
      const key = `${zoneId}|${String(item.text||'')}`;
      const match = recIndex.get(key) || [];
      if(recurringId!=null){
        kind='recurring';
      }else if(match.length===1){
        kind='recurring';
        recurringId = match[0].id;
      }else{
        kind='single';
      }
      if(kind==='recurring' && done){
        done=false;
      }
    }

    if(kind==='recurring' && recurringId==null){
      const key = `${zoneId}|${String(item.text||'')}`;
      const match = recIndex.get(key) || [];
      if(match.length===1){
        recurringId = match[0].id;
      }
    }

    const next = { ...item, zoneId, done, kind, points };
    if(kind==='recurring'){
      const existing = typeof next.recurringId==='number' ? next.recurringId : null;
      next.recurringId = recurringId!=null ? recurringId : existing;
      // Set points from recurring
      const rec = recs.find(r => r.id === next.recurringId);
      if (rec) {
        next.points = Number(rec.points) || 0;
      }
    }else if('recurringId' in next){
      delete next.recurringId;
    }

    if(zoneKind==='noise'){
      const normalizedNoise = normalizeAiScoreForZone({ points: next.points, reason: next.aiReason }, 'noise');
      if(next.points !== normalizedNoise.points){
        next.points = normalizedNoise.points;
        changed=true;
      }
      const nextReason = normalizedNoise.reason;
      if(String(next.aiReason || '') !== nextReason){
        next.aiReason = nextReason;
        changed=true;
      }
    }

    if(item.zoneId!==next.zoneId || item.done!==next.done || item.kind!==next.kind || (kind==='recurring' && item.recurringId!==next.recurringId) || (kind!=='recurring' && 'recurringId' in item) || item.points !== next.points || (zoneKind==='noise' && String(item.aiReason || '') !== String(next.aiReason || ''))){
      changed=true;
    }

    return next;
  }).filter(Boolean);

  if(changed){
    save(LS.TASKS, normalized);
  }

  return normalized;
}

function isTaskActiveToday(t){
  if(!t) return false;
  if(t.kind==='recurring') return true;
  if(t.kind==='single') return !t.done;
  return !t.done;
}

function getZoneActiveTasks(tasks, zoneId){
  return tasks.filter(t=>t.zoneId==zoneId && isTaskActiveToday(t));
}

function describeTaskKind(task, zone){
  if(task.kind==='recurring'){
    return zone && zone.kind==='noise' ? 'Hằng ngày (-)' : 'Hằng ngày';
  }
  return 'Một lần';
}

function taskKindClass(task, zone){
  if(task.kind==='recurring'){
    return zone && zone.kind==='noise' ? 'task-kind recurring negative' : 'task-kind recurring';
  }
  return 'task-kind single';
}

function renderTaskKindBadge(task, zone){
  return `<span class="${taskKindClass(task, zone)}">${describeTaskKind(task, zone)}</span>`;
}

function renderTaskPoints(points, reasonText) {
  const sign = points >= 0 ? '+' : '';
  const className = points >= 0 ? 'positive' : 'negative';
  const rawReason = String(reasonText || '').trim();
  let prioritizedReason = rawReason;
  if(rawReason){
    const segments = rawReason.split(/—| - /).map(part=>part.trim()).filter(Boolean);
    if(segments.length){
      const seen = new Set();
      const noiseSegments = [];
      const otherSegments = [];
      segments.forEach(seg=>{
        const key = seg.toLowerCase();
        if(seen.has(key)) return;
        seen.add(key);
        if(key.startsWith('nhầm zone')){
          noiseSegments.push(seg);
        }else{
          otherSegments.push(seg);
        }
      });
      prioritizedReason = [...noiseSegments, ...otherSegments].join(' — ');
    }
  }
  const safe = prioritizedReason.replace(/"/g, '&quot;');
  return `<span class="task-points ${className}" title="${safe}">${sign}${points}</span>`;
}
function setTasks(a){ save(LS.TASKS,a) }

/* ==============================
   ARCHIVE STORAGE HELPERS
============================== */
function isArchiveEligibleKind(kind){
  return ARCHIVE_ZONE_KINDS.has(kind);
}

function archiveTaskCompletion(task, zone){
  if(!task) return;
  const taskKey = task.id != null ? String(task.id) : '';
  if(!taskKey) return;

  const zoneKind = zone ? zone.kind : '';
  if(!isArchiveEligibleKind(zoneKind)) return;

  const entry = {
    taskId: taskKey,
    text: String(task.text || ''),
    zoneId: zone ? String(zone.id) : '',
    zoneName: zone ? String(zone.name || '') : String(task.zoneName || ''),
    zoneKind,
    completedAt: new Date().toISOString(),
    points: Number(task.points) || 0,
    reason: String(task.aiReason || '').trim()
  };

  const current = getArchive();
  const index = current.findIndex(item => item.taskId === taskKey);
  const next = [...current];
  if(index>-1){
    next[index] = { ...next[index], ...entry };
  }else{
    next.push(entry);
  }
  setArchive(next);
}

function removeTaskFromArchive(taskId){
  const key = taskId != null ? String(taskId) : '';
  if(!key) return;
  const list = getArchive();
  const next = list.filter(item => item.taskId !== key);
  if(next.length !== list.length){
    setArchive(next);
  }
}

/* ==============================
   LB CACHE
============================== */
function getLBCache(){
  return load(LS.LBCACHE, { ts:0, list:[] });
}
function setLBCache(v){
  save(LS.LBCACHE, v);
}
function renderLBRows(rowsEl, list){
  if(!Array.isArray(list) || !list.length){
    rowsEl.innerHTML = '<tr><td colspan="5" class="muted">Chưa có dữ liệu</td></tr>';
    return;
  }
  const enriched = list.map(item=>({
    ...item,
    totalE: calcTotalE(item.level, item.xp)
  }));
  enriched.sort((a,b)=>
    (b.totalE-a.totalE) || (b.level-a.level) || (b.xp-a.xp) || (a.name||'').localeCompare(b.name||'')
  );
  rowsEl.innerHTML = enriched.map((u,i)=>`
    <tr>
      <td>${i+1}</td>
      <td>${u.name||'-'}</td>
      <td>${u.level??'-'}</td>
      <td>${u.totalE??'-'}</td>
      <td>${u.updatedAt?new Date(u.updatedAt).toLocaleString():'-'}</td>
    </tr>
  `).join('');
}

/* ==============================
   SPAWN RECURRING EACH DAY
============================== */
function spawnRecurringIfNeeded(){
  const mark = Number(localStorage.getItem(LS.SPAWN)||0);
  if(mark===getDay()) return;

  const weekday = new Date().getDay();
  const recs = getRecurring();
  const zones = getZones();
  const tasks = getTasks();
  const existingRecurring = new Set(
    tasks
      .filter(t=>t.kind==='recurring' && typeof t.recurringId==='number')
      .map(t=>t.recurringId)
  );
  const fallbackRecurringKeys = new Set(
    tasks
      .filter(t=>t.kind==='recurring' && typeof t.recurringId!=='number')
      .map(t=>`${t.zoneId}|${String(t.text||'')}`)
  );

  for(const r of recs){
    const match = r.type==='daily' ||
      (r.type==='weekly' && Array.isArray(r.days)&&r.days.includes(weekday));
    if(!match) continue;

    const z = zones.find(z=>z.id==r.zoneId);
    if(!z) continue;

    const recKey = `${r.zoneId}|${String(r.text||'')}`;
    if(existingRecurring.has(r.id) || fallbackRecurringKeys.has(recKey)) continue;

    const newTask = {
	  id: Date.now() + Math.random(),
	  text: r.text,
	  zoneId: r.zoneId,
	  done: false,
	  kind: 'recurring',
	  recurringId: r.id,
	  points: Number(r.points) || 0,
	  aiReason: r.reason || ''
	};


    tasks.push(newTask);
    existingRecurring.add(r.id);
    fallbackRecurringKeys.add(recKey);
  }

  setTasks(tasks);
  localStorage.setItem(LS.SPAWN, String(getDay()));
}

/* ==============================
   SYNC / LB FETCH
============================== */
function getSyncCfg(){ return { endpoint: CONFIG.ENDPOINT, autosync: true }; }

async function autoSync(){
  const cfg = getSyncCfg();
  if(!cfg.autosync || !cfg.endpoint) return;
  const p = getProfile();

  const form = new URLSearchParams({
    id:    String(p.id || ''),
    name:  (p.name || 'Player'),
    level: String(p.level || 1),
    xp:    String(p.xp   || 0)
  }).toString();

  try {
    const res = await fetch(cfg.endpoint, {
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body:form
    });
    if(!res.ok){
      console.warn('autoSync: server trả mã', res.status);
    }
  } catch(e){
    console.warn('autoSync failed', e);
  }
}

const scheduleAutoSync = (() => {
  let timer = null;
  const DELAY = 2000;
  return function scheduleAutoSync(){
    if(timer){
      clearTimeout(timer);
    }
    timer = setTimeout(()=>{
      timer = null;
      autoSync();
    }, DELAY);
  };
})();

async function fetchLeaderboardAndCache(){
  const cfg = getSyncCfg();
  if (!cfg.endpoint) return;

  // Tăng timeout và xử lý AbortError êm
  const controller = new AbortController();
  const timeoutMs = 15000; // 15s (trước là 8000)
  const t = setTimeout(() => controller.abort(), timeoutMs);

  try {
    const r = await fetch(cfg.endpoint, {
      signal: controller.signal,
      cache: 'no-store' // tránh cache treo
    });
    clearTimeout(t);

    if (!r.ok) throw new Error('HTTP ' + r.status);

    const data = await r.json();

    const leaderboardList = Array.isArray(data)
      ? data
      : Array.isArray(data.lb)
        ? data.lb
        : [];
    if (leaderboardList.length > 0) {
      setLBCache({ ts: Date.now(), list: leaderboardList });
    }

  } catch (e) {
    clearTimeout(t);
    // CHỈ SỬA LẠI 3 DÒNG NÀY: AbortError thì im lặng, không log cảnh báo
    if (e && e.name === 'AbortError') {
      // console.debug('Leaderboard fetch timed out');
      return;
    }
    console.warn('fetchLeaderboardAndCache failed', e);
  }
}


function backgroundBoardRefresh(){
  // Gọi nhẹ, không ném lỗi ra console
  fetchLeaderboardAndCache().catch(() => {});
}


/* ==============================
   DANGER LOCAL WIPE
============================== */
function wipeLocalPlayer(){
  localStorage.removeItem(LS.PROFILE);
  localStorage.removeItem(LS.LBCACHE);
  alert('Đã xoá hồ sơ local. Reload trang để tạo người chơi mới.');
  location.reload();
}

/* ==============================
   END DAY / RESET
============================== */
function handleResetPoints(){
  if(confirm('Reset Level=1 & E=0?')){
    resetPoints();
    alert('Đã reset điểm.');
    render('settings');
  }
}

function performDayRollover(opts={}){
  const auto=!!opts.auto;
  if(isRolloverRunning) return false;
  isRolloverRunning=true;
  try{
    const zones=getZones();
    const tasks=getTasks();
    const todaySim=getDay();

    // Calculate productivity bonus
    const todayTasks = tasks.filter(t => isTaskActiveToday(t) && t.done);
    let totalDayPoints = 0;
    let noisePenalty = 0;
    const noiseZone = zones.find(z => z.kind === 'noise');
    todayTasks.forEach(t => {
      const pts = Number(t.points) || 0;
      totalDayPoints += pts;
      if (noiseZone && t.zoneId === noiseZone.id) {
        noisePenalty += Math.min(0, pts);
      }
    });
    if (totalDayPoints >= 10 && noisePenalty >= -1) {
      let bonus = 3;
      if (totalDayPoints >= 15) bonus = 5;
      if (totalDayPoints >= 20) bonus = 8;
      addXP(bonus);
    }

    // Daily penalty
    addXP(-5);

    pushHistSnapshot();

    clearFlagsFor(todaySim);
    nextDay();
    const remaining = tasks.filter(t=>t.kind!=='recurring');
    setTasks(remaining);
    localStorage.removeItem(LS.SPAWN);
    spawnRecurringIfNeeded();

    setLastRealDate(todayDM());

    if(!auto){
      alert('Đã qua ngày.');
    }

    autoSync()
      .then(()=>fetchLeaderboardAndCache())
      .catch(()=>{});

    renderHero();
    return true;
  } finally {
    isRolloverRunning=false;
  }
}

function handleEndDay(){
  if(performDayRollover({auto:false})){
    render('settings');
  }
}

function syncDayWithCalendar(){
  const today = todayDM();
  const lastReal = getLastRealDate();
  if(!lastReal){
    setLastRealDate(today);
    return false;
  }
  if(lastReal===today){
    return false;
  }
  return performDayRollover({auto:true});
}

function startDaySyncMonitoring(){
  if(daySyncTimer!==null) return;
  daySyncTimer=setInterval(()=>{
    if(syncDayWithCalendar()){
      render('tasks');
    }
  }, 60*1000);

  if(!daySyncVisHandler){
    daySyncVisHandler=()=>{
      if(!document.hidden && syncDayWithCalendar()){
        render('tasks');
      }
    };
    document.addEventListener('visibilitychange', daySyncVisHandler);
  }
}

function stopDaySyncMonitoring(){
  if(daySyncTimer!==null){
    clearInterval(daySyncTimer);
    daySyncTimer=null;
  }
  if(daySyncVisHandler){
    document.removeEventListener('visibilitychange', daySyncVisHandler);
    daySyncVisHandler=null;
  }
}

/* ==============================
   MINI CHART DRAWER
============================== */
function drawChart(canvasId, values){
  const cvs = document.getElementById(canvasId);
  if(!cvs) return;
  const ctx = cvs.getContext('2d');

  const ratio = window.devicePixelRatio || 1;
  const displayWidth = Math.floor(cvs.clientWidth || cvs.offsetWidth || 300);
  const displayHeight = Math.floor(cvs.clientHeight || cvs.offsetHeight || 160);
  if(displayWidth === 0 || displayHeight === 0){
    return;
  }

  cvs.width = Math.round(displayWidth * ratio);
  cvs.height = Math.round(displayHeight * ratio);

  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(ratio, ratio);
  ctx.clearRect(0,0,displayWidth,displayHeight);
  ctx.lineJoin = ctx.lineCap = 'round';

  ctx.fillStyle = "rgba(255,255,255,0.6)";
  ctx.fillRect(0,0,displayWidth,displayHeight);

  if(!values || !values.length){
    ctx.fillStyle="#555";
    ctx.font="14px system-ui";
    ctx.textBaseline = 'top';
    ctx.fillText("Chưa có dữ liệu", 10, 24);
    return;
  }

  const minV = Math.min(...values);
  const maxV = Math.max(...values);
  const padX = 24;
  const padY = 24;
  const span = (maxV-minV)||1;
  const usableW = (displayWidth-2*padX);
  const usableH = (displayHeight-2*padY);

  const points = values.map((v,i)=>{
    const ratioX = (values.length===1)?0:(i/(values.length-1));
    const x = padX + (usableW * ratioX);
    const y = displayHeight - padY - (usableH * ((v-minV)/span));
    return {x,y,value:v};
  });

  ctx.save();
  ctx.strokeStyle = 'rgba(27,30,46,0.08)';
  ctx.lineWidth = 1;
  ctx.setLineDash([4,6]);
  const gridLines = 4;
  for(let i=0;i<=gridLines;i++){
    const gy = padY + (usableH * (i/gridLines));
    ctx.beginPath();
    ctx.moveTo(padX, gy);
    ctx.lineTo(displayWidth-padX, gy);
    ctx.stroke();
  }
  ctx.restore();

  ctx.save();
  ctx.strokeStyle = 'rgba(27,30,46,0.14)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padX, padY-4);
  ctx.lineTo(padX, displayHeight-padY);
  ctx.lineTo(displayWidth-padX+4, displayHeight-padY);
  ctx.stroke();
  ctx.restore();

  const gradLine = ctx.createLinearGradient(padX,0,displayWidth-padX,0);
  gradLine.addColorStop(0,"#8b7cff");
  gradLine.addColorStop(1,"#b09bff");

  ctx.beginPath();
  points.forEach((pt,i)=>{
    if(i===0){
      ctx.moveTo(pt.x, pt.y);
    }else{
      ctx.lineTo(pt.x, pt.y);
    }
  });
  ctx.lineWidth = 3;
  ctx.strokeStyle = gradLine;
  ctx.shadowColor = 'rgba(139,124,255,0.35)';
  ctx.shadowBlur = 12;
  ctx.stroke();
  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;

  ctx.beginPath();
  points.forEach((pt,i)=>{
    if(i===0){
      ctx.moveTo(pt.x, pt.y);
    }else{
      ctx.lineTo(pt.x, pt.y);
    }
  });
  ctx.lineTo(points[points.length-1].x, displayHeight-padY);
  ctx.lineTo(points[0].x, displayHeight-padY);
  ctx.closePath();
  const gradFill = ctx.createLinearGradient(0,padY,0,displayHeight-padY);
  gradFill.addColorStop(0,'rgba(139,124,255,0.18)');
  gradFill.addColorStop(1,'rgba(139,124,255,0)');
  ctx.fillStyle = gradFill;
  ctx.fill();

  ctx.beginPath();
  points.forEach((pt,i)=>{
    if(i===0){
      ctx.moveTo(pt.x, pt.y);
    }else{
      ctx.lineTo(pt.x, pt.y);
    }
  });
  ctx.lineWidth = 3;
  ctx.strokeStyle = gradLine;
  ctx.stroke();

  points.forEach((pt,i)=>{
    ctx.beginPath();
    const isLast = i === points.length-1;
    const radius = isLast ? 5 : 3;
    ctx.arc(pt.x, pt.y, radius, 0, Math.PI*2);
    if(isLast){
      ctx.fillStyle = '#ff3425';
      ctx.strokeStyle = 'rgba(255,255,255,0.85)';
      ctx.lineWidth = 3;
    }else{
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = 'rgba(139,124,255,0.6)';
      ctx.lineWidth = 2;
    }
    ctx.fill();
    ctx.stroke();
  });

  const lastPoint = points[points.length-1];
  const lastVal = lastPoint.value;
  const label = String(lastVal);
  ctx.font = '600 13px system-ui';
  ctx.textBaseline = 'middle';
  ctx.textAlign = 'left';
  const metrics = ctx.measureText(label);
  const labelPadX = 8;
  const labelHeight = 24;
  const labelWidth = metrics.width + labelPadX*2;
  let labelX = lastPoint.x + 12;
  let labelY = lastPoint.y - labelHeight/2 - 6;
  if(labelX + labelWidth > displayWidth - padX){
    labelX = displayWidth - padX - labelWidth;
  }
  if(labelY < padY){
    labelY = padY;
  }
  if(labelY + labelHeight > displayHeight - padY){
    labelY = displayHeight - padY - labelHeight;
  }

  const radiusRect = 10;
  ctx.beginPath();
  const r = Math.min(radiusRect, labelHeight/2, labelWidth/2);
  ctx.moveTo(labelX + r, labelY);
  ctx.lineTo(labelX + labelWidth - r, labelY);
  ctx.quadraticCurveTo(labelX + labelWidth, labelY, labelX + labelWidth, labelY + r);
  ctx.lineTo(labelX + labelWidth, labelY + labelHeight - r);
  ctx.quadraticCurveTo(labelX + labelWidth, labelY + labelHeight, labelX + labelWidth - r, labelY + labelHeight);
  ctx.lineTo(labelX + r, labelY + labelHeight);
  ctx.quadraticCurveTo(labelX, labelY + labelHeight, labelX, labelY + labelHeight - r);
  ctx.lineTo(labelX, labelY + r);
  ctx.quadraticCurveTo(labelX, labelY, labelX + r, labelY);
  ctx.closePath();
  ctx.fillStyle = 'rgba(27,30,46,0.9)';
  ctx.shadowColor = 'rgba(0,0,0,0.12)';
  ctx.shadowBlur = 6;
  ctx.fill();
  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;

  ctx.fillStyle = '#fff';
  ctx.fillText(label, labelX + labelPadX, labelY + labelHeight/2);
}

/* ==============================
   SWIPE TASK HANDLERS
============================== */
function attachSwipeHandlersForTasks(){
  const rows = [...document.querySelectorAll('li.task')];

  rows.forEach(li=>{
    const inner  = li.querySelector('.task-inner');
    const delBtn = li.querySelector('.del-btn');

    let startX = 0;
    let currentX = 0;
    let isDown = false;
    let opened = li.classList.contains('show-del');
    let justSwiped = false;
    let swipeResetTimer = null;
    let hasDragged = false;
    let pendingDragFromDel = false;
    let pendingStartX = 0;

    function openRow(){
      li.classList.add('show-del');
      li.classList.remove('dragging');
      inner.style.transform = '';
      delBtn.style.transform = '';
      opened = true;
    }

    function closeRow(){
      li.classList.remove('show-del');
      li.classList.remove('dragging');
      inner.style.transform = '';
      delBtn.style.transform = 'translateX(60px)';
      opened = false;
      justSwiped = false;
      if(swipeResetTimer){
        clearTimeout(swipeResetTimer);
        swipeResetTimer = null;
      }
    }

    function applyDrag(dx){
      let offset = dx;
      if(offset < -60) offset = -60;
      if(offset > 0)   offset = 0;

      inner.style.transform = `translateX(${offset}px)`;

      const btnOffset = 60 + offset;
      delBtn.style.transform = `translateX(${btnOffset}px)`;
    }

    function startDrag(clientX){
      isDown = true;
      hasDragged = false;
      pendingDragFromDel = false;
      startX = clientX;
      currentX = clientX;
      li.classList.add('dragging');

      if(opened){
        inner.style.transform   = 'translateX(-60px)';
        delBtn.style.transform  = 'translateX(0px)';
      }
    }

    function canStartDrag(target, clientX){
      if(target.closest('.del-btn')){
        return true;
      }

      if(target.closest('input, button, select, textarea, a, label')){
        return false;
      }

      if(target.closest('.task-inner') || target.closest('.txt')){
        return true;
      }

      const liRect = li.getBoundingClientRect();
      return clientX >= (liRect.right - 60);
    }

    function moveDrag(clientX){
      if(!isDown) return;
      currentX = clientX;
      const dx = currentX - startX;

      if(opened){
        applyDrag(-60 + dx);
      }else{
        applyDrag(dx);
      }
    }

    function endDrag(){
      if(!isDown) return;
      isDown = false;

      const dx = currentX - startX;

      let openedViaSwipe = false;

      if(opened){
        if(dx > 30){
          closeRow();
        }else{
          openRow();
          openedViaSwipe = true;
        }
      }else{
        if(dx < -30){
          openRow();
          openedViaSwipe = true;
        }else{
          closeRow();
        }
      }

      if(openedViaSwipe){
        justSwiped = true;
        if(swipeResetTimer){
          clearTimeout(swipeResetTimer);
        }
        swipeResetTimer = setTimeout(()=>{
          justSwiped = false;
          swipeResetTimer = null;
        }, 250);
      }

      hasDragged = false;
    }

    // Touch
    li.addEventListener('touchstart', e=>{
      const clientX = e.touches[0].clientX;
      if(e.target.closest('.del-btn')){
        pendingDragFromDel = true;
        pendingStartX = clientX;
        return;
      }

      pendingDragFromDel = false;
      pendingStartX = 0;

      if(!canStartDrag(e.target, clientX)) return;
      startDrag(clientX);
    }, {passive:false});

    li.addEventListener('touchmove', e=>{
      const clientX = e.touches[0].clientX;

      if(pendingDragFromDel){
        const dx = clientX - pendingStartX;
        if(Math.abs(dx) > 3){
          startDrag(pendingStartX);
          hasDragged = true;
          moveDrag(clientX);
          e.preventDefault();
        }
        return;
      }

      if(!isDown) return;

      const dx = clientX - startX;
      if(!hasDragged && Math.abs(dx) > 3){
        hasDragged = true;
      }

      if(hasDragged){
        moveDrag(clientX);
        e.preventDefault();
      }
    }, {passive:false});

    li.addEventListener('touchend', ()=>{
      if(pendingDragFromDel){
        pendingDragFromDel = false;
        pendingStartX = 0;
        return;
      }
      endDrag();
    });

    // Mouse
    li.addEventListener('mousedown', e=>{
      if(!canStartDrag(e.target, e.clientX)) return;
      startDrag(e.clientX);
      e.preventDefault();
    });

    li.addEventListener('mousemove', e=>{
      if(!isDown) return;
      moveDrag(e.clientX);
    });

    li.addEventListener('mouseup', ()=>{
      endDrag();
    });

    li.addEventListener('mouseleave', ()=>{
      if(isDown){
        endDrag();
      }
    });

    inner.addEventListener('click', e=>{
      if(li.classList.contains('show-del')){
        if(justSwiped){
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        e.preventDefault();
        e.stopPropagation();
        closeRow();
      }
    });
  });

  document.querySelectorAll('.del-btn').forEach(btn=>{
    btn.onclick = (e)=>{
      e.stopPropagation();
      const id = Number(btn.dataset.id);
      setTasks(getTasks().filter(t=>t.id!==id));
      render('tasks');
    };
  });
}

/* ==============================
   VIEW FUNCTIONS
============================== */
const view = document.getElementById('view');
const tabsBar = document.getElementById('tabsBar');
let settingsUnlocked=false;
let daySyncTimer=null;
let daySyncVisHandler=null;
let isRolloverRunning=false;

function ensureSettingsAuth(){
  if(settingsUnlocked) return true;
  const pass=prompt('Nhập mật khẩu Settings:');
  if(pass===CONFIG.SETTINGS_PASS){
    settingsUnlocked=true;
    return true;
  }
  alert('Sai mật khẩu');
  return false;
}

/* Build tabs bar */
function buildTabsBar(active){
  tabsBar.innerHTML = [
    {id:'tasks', label:'Nhiệm vụ', icon:'✅'},
    {id:'archive', label:'Lưu trữ', icon:'🗂️'},
    {id:'leaderboard', label:'Leaderboard', icon:'🏆'},
    {id:'stats', label:'Biểu đồ', icon:'📈'},
    {id:'settings', label:'Settings', icon:'⚙️'}
  ].map(t=>`
    <button class="tab-btn ${t.id===active?'active':''}" data-tab="${t.id}" aria-label="${t.label}" title="${t.label}">
      ${t.icon}
    </button>
  `).join('');

  [...tabsBar.querySelectorAll('.tab-btn')].forEach(btn=>{
    btn.onclick=()=>{
      render(btn.dataset.tab);
    };
  });
}

/* TASKS */
async function viewTasks(){
  spawnRecurringIfNeeded();

  let zones=getZones();
  const tasks=getTasks();
  const dateNowDM = todayDM();
  let priorityZone = zones.find(z => z.kind === 'priority');

  if (!priorityZone) {
    const fallback = DEFAULT_ZONES.find(z=>z.kind==='priority') || {name: 'Zone Quan trọng', kind: 'priority', bg: ''};
    const restored = {
      id: Date.now(),
      name: fallback.name,
      kind: fallback.kind,
      bg: fallback.bg
    };
    zones = [...zones, restored];
    setZones(zones);
    priorityZone = restored;
    alert('Không tìm thấy Zone Quan trọng, hệ thống đã tạo mới để bạn tiếp tục.');
  }

  const groups = zones.map(z=>{
    const zoneTasks = tasks
      .filter(t=>t.zoneId==z.id)
      .sort((a,b)=>{
        if(a.kind===b.kind) return Number(a.done)-Number(b.done);
        return a.kind==='recurring' ? -1 : 1;
      });

    const list = zoneTasks;
    const activeList = list.filter(isTaskActiveToday);
    const activeDone = activeList.filter(t=>t.done).length;
    return {
      z,
      list,
      activeList,
      activeDone,
      activeTotal: activeList.length,
      kindLabel: ZONE_KIND_LABELS[z.kind] || 'Zone',
      progressText: activeList.length ? `${activeDone}/${activeList.length}` : '0'
    };
  });

  view.innerHTML = `
    <div class="top">
      <span class="pill">Ngày: <b>${dateNowDM}</b></span>
    </div>

    <div class="creator">
      <input id="taskText" placeholder="Thêm nhiệm vụ… (Enter)">
      <select id="taskZone">${zones.map(z=>`<option value="${z.id}">${z.name}</option>`).join('')}</select>
      <button class="btn-primary" id="btnAdd">Thêm</button>
    </div>

    ${groups.map(g=>{
      const z=g.z;
      const headerClass = z.bg ? 'imgHead' : '';
      const headerStyle = z.bg
        ? `background-image:linear-gradient(0deg,rgba(0,0,0,.5),rgba(0,0,0,.15)),url('${z.bg}');`
        : '';
      const emptyStateHtml = `
        <li class="task">
          <div class="task-inner">
            <span class="muted">Chưa có task trong Zone này.</span>
          </div>
        </li>`;

      const listHtml = g.list.length
        ? g.list.map(t=>{
            return `
              <li class="task ${t.done?'done':''}" data-id="${t.id}" data-kind="${t.kind||'single'}">
                <div class="task-inner">
                  <div class="left">
                    <input type="checkbox" data-id="${t.id}" ${t.done?'checked':''}>
                    <span class="txt">${t.text}</span>
                    ${renderTaskKindBadge(t, z)}
                    ${renderTaskPoints(t.points, t.aiReason)}
                  </div>
                </div>
                ${t.aiReason ? `<div class="ai-reason">${t.aiReason}</div>` : ''}
                <button class="del-btn" data-id="${t.id}">×</button>
              </li>
            `;
          }).join('')
        : emptyStateHtml;

      return `
      <section class="zone">
        <header class="${headerClass}" style="${headerStyle}">
          <div><b>${z.name}</b> <span class="badge">${g.kindLabel}</span></div>
          <div class="badge">${g.progressText}</div>
        </header>
        <ul>
          ${listHtml}
        </ul>
      </section>`;
    }).join('')}
  `;

  const inp = document.getElementById('taskText');
  const sel = document.getElementById('taskZone');

  async function addNow(){
    const text=(inp.value||'').trim(); if(!text) return;
    const zoneId = Number(sel.value);
    const z = zones.find(z=>z.id==zoneId);
    if(!z) return;

    // Limit for Zone E
    if (z.kind === 'e') {
      const activeInE = getZoneActiveTasks(getTasks(), z.id).length;
      if (activeInE >= 5) {
        alert('Zone E chỉ tối đa 5 task/ngày!');
        return;
      }
    }

    const ai = await getTaskPoints(text, z.kind);
    const normalizedAi = normalizeAiScoreForZone(ai, z.kind);
    const currentTasks = getTasks();
    const newTasks = [...currentTasks];

    if(DAILY_ZONE_KINDS.has(z.kind)){
      const recs = getRecurring();
      const existingRec = recs.find(r=>r.zoneId==z.id && r.type==='daily' && (r.text||'')===text);
      let rec = existingRec;
      if(!rec){
        rec = await addRecurring({
          text,
          zoneId:z.id,
          type:'daily',
          autoKind:z.kind
        });
      }else{
        let recChanged = false;
        if(Number(rec.points) !== normalizedAi.points){
          recChanged = true;
        }
        if(String(rec.reason || '') !== normalizedAi.reason){
          recChanged = true;
        }
        if(recChanged){
          const updatedRecs = recs.map(r=>r.id===rec.id?{...r, points: normalizedAi.points, reason: normalizedAi.reason}:r);
          save(LS.RECUR, updatedRecs);
          rec = { ...rec, points: normalizedAi.points, reason: normalizedAi.reason };
        }
      }
      const duplicate = newTasks.some(t=>t.zoneId==z.id && t.kind==='recurring' && t.recurringId===rec.id);
      if(!duplicate){
        newTasks.push({
                  id: Date.now() + Math.random(),
                  text,
                  zoneId: z.id,
                  done: false,
                  kind: 'recurring',
                  recurringId: rec.id,
                  points: normalizedAi.points,
                  aiCategory: normalizedAi.category,
                  aiReason: normalizedAi.reason,
                  zoneLabel: normalizedAi.zone
                });

      }
    } else {
      newTasks.push({
                  id: Date.now(),
                  text,
                  zoneId: z.id,
                  done: false,
                  kind: 'single',
                  points: normalizedAi.points,
                  aiCategory: normalizedAi.category,
                  aiReason: normalizedAi.reason,
                  zoneLabel: normalizedAi.zone
                });
    }

    setTasks(newTasks);
    inp.value='';
    render('tasks');
  }

  document.getElementById('btnAdd').onclick = addNow;
  inp.onkeydown=(e)=>{ if(e.key==='Enter') addNow(); };

  window.onkeydown=(e)=>{
    const tag=(document.activeElement?.tagName||'').toLowerCase();
    if(e.key==='Tab' && !['input','select','textarea','button'].includes(tag)){
      e.preventDefault();
      inp.focus();
    }
  };

  // tick task
  view.querySelectorAll('input[type="checkbox"]').forEach(cb=>{
    cb.onchange=()=>{
      const id = Number(cb.dataset.id);
      const list = getTasks();
      const index = list.findIndex(task=>task.id===id);
      if(index<0) return;

      const original = list[index];
      const updated = { ...original, done: cb.checked };
      const delta = cb.checked ? (Number(original.points) || 0) : -(Number(original.points) || 0);
      const zone = zones.find(z=>z.id==updated.zoneId);
      const zoneKind = zone ? zone.kind : '';

      const nextTasks = list.map(task=>task.id===id?updated:task);
      addXP(delta);
      setTasks(nextTasks);

      if(cb.checked){
        if(isArchiveEligibleKind(zoneKind)){
          archiveTaskCompletion(updated, zone);
        }
      }else{
        removeTaskFromArchive(updated.id);
      }

      render('tasks');
    };
  });

  attachSwipeHandlersForTasks();
}

function formatArchiveDisplayTime(iso){
  if(!iso) return '';
  const date = new Date(iso);
  if(Number.isNaN(date.getTime())) return '';
  return date.toLocaleString('vi-VN');
}

function renderArchiveItem(item){
  const kindLabel = item.zoneKind ? (ZONE_KIND_LABELS[item.zoneKind] || item.zoneKind) : '';
  const zoneName = item.zoneName || '';
  let zoneDisplay = '';
  if(zoneName && kindLabel){
    zoneDisplay = `${zoneName} (${kindLabel})`;
  }else if(zoneName){
    zoneDisplay = zoneName;
  }else if(kindLabel){
    zoneDisplay = kindLabel;
  }

  const metaParts = [];
  if(zoneDisplay) metaParts.push(zoneDisplay);
  const timeText = formatArchiveDisplayTime(item.completedAt);
  if(timeText) metaParts.push(timeText);
  if(item.points){
    metaParts.push(`${formatSignedNumber(item.points)} E`);
  }

  const reasonText = (item.reason || '').trim();
  const metaHtml = metaParts.length ? `
    <div class="archive-meta">
      ${metaParts.map((part, idx)=> idx?`<span class="sep">•</span><span>${part}</span>`:`<span>${part}</span>`).join('')}
    </div>
  ` : '';
  const reasonHtml = reasonText ? `<div class="archive-reason">Lý do: ${reasonText}</div>` : '';

  return `
    <li class="archive-item" data-task-id="${item.taskId}">
      <div class="archive-info">
        <div class="archive-title">${item.text}</div>
        ${metaHtml}
        ${reasonHtml}
      </div>
      <div class="archive-actions">
        <button class="btn-ghost btn-sm" type="button" data-copy="${item.taskId}">Copy</button>
      </div>
    </li>
  `;
}

function formatArchiveCopyText(item){
  const kindLabel = item.zoneKind ? (ZONE_KIND_LABELS[item.zoneKind] || item.zoneKind) : '';
  const zoneName = item.zoneName || '';
  let zoneDisplay = '';
  if(zoneName && kindLabel){
    zoneDisplay = `${zoneName} (${kindLabel})`;
  }else if(zoneName){
    zoneDisplay = zoneName;
  }else if(kindLabel){
    zoneDisplay = kindLabel;
  }

  const segments = [String(item.text || '').trim()];
  if(zoneDisplay) segments.push(zoneDisplay);
  const timeText = formatArchiveDisplayTime(item.completedAt);
  if(timeText) segments.push(timeText);
  if(item.points){
    segments.push(`${formatSignedNumber(item.points)} E`);
  }
  const reasonText = (item.reason || '').trim();
  if(reasonText){
    segments.push(`Lý do: ${reasonText}`);
  }
  return segments.filter(Boolean).join(' — ');
}

function viewArchive(){
  const archived = getArchive();
  const sorted = [...archived].sort((a,b)=>{
    const timeA = Date.parse(a.completedAt || '');
    const timeB = Date.parse(b.completedAt || '');
    const safeA = Number.isNaN(timeA) ? 0 : timeA;
    const safeB = Number.isNaN(timeB) ? 0 : timeB;
    return safeB - safeA;
  });

  const listHtml = sorted.length
    ? `<ul class="archive-list">${sorted.map(renderArchiveItem).join('')}</ul>`
    : `<p class="archive-empty">Chưa có nhiệm vụ nào được lưu trữ.</p>`;

  view.innerHTML = `
    <div class="card" style="margin-top:0">
      <h3>Lưu trữ nhiệm vụ</h3>
      <div class="muted">Các nhiệm vụ đã hoàn thành từ Zone Quan trọng và Zone Thường.</div>
      <div class="archive-toolbar">
        <button class="btn-danger btn-sm" type="button" id="btnClearArchive" ${sorted.length?'':'disabled'}>Xóa tất cả</button>
      </div>
      ${listHtml}
    </div>
  `;

  const archiveMap = new Map(sorted.map(item=>[item.taskId, item]));
  view.querySelectorAll('[data-copy]').forEach(btn=>{
    btn.onclick = async ()=>{
      const key = String(btn.dataset.copy || '');
      const entry = archiveMap.get(key);
      if(!entry) return;
      if(!navigator.clipboard || typeof navigator.clipboard.writeText !== 'function'){
        alert('Trình duyệt không hỗ trợ copy vào clipboard.');
        return;
      }
      try{
        await navigator.clipboard.writeText(formatArchiveCopyText(entry));
        btn.textContent = 'Đã copy!';
        btn.disabled = true;
        setTimeout(()=>{ render('archive'); }, 800);
      }catch(err){
        console.error(err);
        alert('Không thể copy vào clipboard. Vui lòng thử lại.');
      }
    };
  });

  const clearBtn = document.getElementById('btnClearArchive');
  if(clearBtn){
    clearBtn.onclick = ()=>{
      if(!sorted.length) return;
      if(confirm('Bạn có chắc muốn xóa tất cả nhiệm vụ đã lưu?')){
        setArchive([]);
        render('archive');
      }
    };
  }
}

/* LEADERBOARD */
function viewLeaderboard(){
  const cache = getLBCache();

  view.innerHTML = `
    <div class="card" style="margin-top:0">
      <h3>Leaderboard</h3>
      <div class="muted">
        Dữ liệu được tải nền khi mở app. Nhấn "Tải lại" để cập nhật.
      </div>
      <div style="margin:10px 0;display:flex;gap:8px;flex-wrap:wrap">
        <button class="btn-ghost" id="reload">Tải lại</button>
        <p id="lbStatus" class="muted" style="margin:0"></p>
      </div>
      <div class="table-wrap">
        <table id="tbl">
          <thead>
            <tr>
              <th>#</th><th>Người chơi</th><th>Level</th><th>E</th><th>Cập nhật</th>
            </tr>
          </thead>
          <tbody id="rows"></tbody>
        </table>
      </div>
    </div>
  `;

  const rows = document.getElementById('rows');

  function fallbackLocalProfileList(){
    const p=getProfile();
    const totalE = calcTotalE(p.level, p.xp);
    return [{
      name:p.name||'Player',
      level:p.level||1,
      xp:p.xp||0,
      totalE,
      updatedAt:new Date().toISOString()
    }];
  }

  renderLBRows(rows, cache.list.length ? cache.list : fallbackLocalProfileList());

  const reloadBtn = document.getElementById('reload');
  const statusEl = document.getElementById('lbStatus');
  reloadBtn.dataset.defaultLabel = reloadBtn.textContent;

  function setLoadingState(isLoading){
    if(isLoading){
      reloadBtn.disabled = true;
      reloadBtn.dataset.loading = 'true';
      reloadBtn.textContent = 'Đang tải...';
    }else{
      reloadBtn.disabled = false;
      reloadBtn.removeAttribute('data-loading');
      reloadBtn.textContent = reloadBtn.dataset.defaultLabel;
    }
  }

  reloadBtn.onclick = async ()=>{
    setLoadingState(true);
    statusEl.textContent = 'Đang tải bảng xếp hạng...';
    try{
      await fetchLeaderboardAndCache();
      const fresh = getLBCache();
      renderLBRows(rows, fresh.list.length ? fresh.list : fallbackLocalProfileList());
      statusEl.textContent = `Đã cập nhật lúc ${new Date().toLocaleTimeString('vi-VN')}`;
    }catch(err){
      console.error(err);
      statusEl.textContent = 'Không thể tải leaderboard. Vui lòng thử lại sau.';
    }finally{
      setLoadingState(false);
    }
  };
}

/* STATS */
function viewStats(){
  const hist = getHist();
  const last7  = hist.slice(-7 ).map(r=>r.xp);
  const last30 = hist.slice(-30).map(r=>r.xp);

  view.innerHTML = `
    <div class="card chart-card" style="margin-top:0">
      <h3>Biểu đồ 7 ngày (E)</h3>
      <canvas id="chart7"></canvas>
    </div>

    <div class="card chart-card">
      <h3>Biểu đồ 30 ngày (E)</h3>
      <canvas id="chart30"></canvas>
    </div>

    <div class="muted" style="margin-top:12px;font-size:13px">
      Lịch sử được lưu mỗi lần bạn bấm "Qua ngày".
    </div>
  `;

  drawChart("chart7", last7);
  drawChart("chart30", last30);
}

/* SETTINGS */
function viewSettings(){
  const p=getProfile();
  const zones=getZones();
  const recs=getRecurring();
  const {level,xp,need}=getLevelInfo();
  const dateNowDM=todayDM();

  view.innerHTML = `
    <div class="card" style="margin-top:0">
      <h3>Ngày & Điểm</h3>
      <div class="row">
        <div>Thông tin hiện tại</div>
        <div class="grid" style="grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:8px">
          <div class="pill">Ngày: <b>${dateNowDM}</b></div>
          <div class="pill">Level: <b>${level}</b></div>
          <div class="pill">E: <b>${xp}</b>${need?` / ${need}`:''}</div>
        </div>
      </div>
      <div class="bar"><div class="fill" style="width:${need?Math.min(100,Math.round(xp/need*100)):100}%;"></div></div>

      <div class="row">
        <div>Hành động</div>
        <div class="grid" style="grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:8px">
          <button class="btn-ghost" id="btnEnd">Qua ngày</button>
          <button class="btn-danger" id="btnReset">Reset điểm</button>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Hồ sơ người chơi</h3>
      <div class="row">
        <div>Tên người chơi</div>
        <div class="grid" style="grid-template-columns:1fr auto;align-items:center">
          <input id="name" value="${p.name||''}">
          <button class="btn-primary" id="saveName">Lưu</button>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Zones</h3>
      <div class="grid">
        <div class="row"><div>Tên Zone</div><input id="zName" placeholder="Công việc"></div>
        <div class="row"><div>Loại Zone</div>
          <select id="zKind">${renderZoneKindOptions('regular')}</select>
        </div>
        <div class="row"><div>Hình nền Zone</div>
          <input id="zBg" type="file" accept="image/*">
        </div>
        <div class="row"><div></div><button class="btn-primary" id="addZone">+ Thêm Zone</button></div>
      </div>

      <div class="table-wrap" style="margin-top:12px">
        <table>
          <thead>
            <tr>
              <th>Tên</th>
              <th>Loại</th>
              <th>Nền</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="zoneT">
            ${zones.map(z=>`
              <tr data-id="${z.id}">
                <td><input name="name" value="${z.name}"></td>
                <td>
                  <select name="kind">${renderZoneKindOptions(z.kind)}</select>
                </td>
                <td>
                  <div class="thumb" style="background-image:url('${z.bg||''}')"></div>
                  <input class="bgUpload" data-id="${z.id}" type="file" accept="image/*" style="margin-top:6px">
                </td>
                <td><button class="btn-danger zdel" data-id="${z.id}">Xoá</button></td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3>Tasks lặp (Hằng ngày / Theo tuần)</h3>
      <div class="row"><div>Mô tả</div><input id="rText" placeholder="Tập thể dục 15’"></div>
      <div class="row"><div>Zone</div>
        <select id="rZone">
          ${zones.filter(z => !DAILY_ZONE_KINDS.has(z.kind)).map(z=>`<option value="${z.id}">${z.name}</option>`).join('')}
        </select>
      </div>
      <div class="row"><div>Kiểu</div>
        <select id="rType">
          <option value="daily">Hằng ngày</option>
          <option value="weekly">Theo thứ</option>
        </select>
      </div>
      <div class="row" id="rDaysRow" style="display:none">
        <div>Chọn thứ</div>
        <div class="grid" style="grid-template-columns:repeat(7, minmax(40px,1fr));gap:4px;font-size:14px">
          ${['CN','T2','T3','T4','T5','T6','T7'].map((l,i)=>`
            <label style="display:flex;align-items:center;gap:4px">
              <input type="checkbox" value="${i}"> ${l}
            </label>
          `).join('')}
        </div>
      </div>
      <div class="row">
        <div></div>
        <button class="btn-primary" id="addRec">+ Thêm Task lặp</button>
      </div>

      <div class="table-wrap" style="margin-top:12px">
        <table>
          <thead>
            <tr>
              <th>Mô tả</th><th>Zone</th><th>Kiểu</th><th>Thứ</th><th>Điểm</th><th></th>
            </tr>
          </thead>
          <tbody id="recT">
            ${recs.map(r=>{
              const zn = zones.find(z=>z.id==r.zoneId)?.name||'(xoá)';
              return `
                <tr>
                  <td>${r.text}</td>
                  <td>${zn}</td>
                  <td>${r.type}</td>
                  <td>${r.type==='weekly'?(r.days||[]).join(', '):'-'}</td>
                  <td>${formatSignedNumber(r.points || 0)}</td>
                  <td><button class="btn-danger rdel" data-id="${r.id}">Xoá</button></td>
                </tr>`;
            }).join('')}
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3>Quản trị / Dữ liệu cục bộ</h3>
      <div class="row">
        <div>Xoá hồ sơ người chơi LOCAL (máy này)</div>
        <div><button class="btn-danger" id="wipeLocalBtn">Xoá hồ sơ local</button></div>
      </div>
    </div>
  `;

  // helper đọc file => base64
  function readFileAsDataURL(file, cb){
    const reader=new FileReader();
    reader.onload=()=>cb(reader.result);
    reader.readAsDataURL(file);
  }

  /* Ngày & Điểm buttons */
  document.getElementById('btnEnd').onclick = ()=>{ handleEndDay(); };
  document.getElementById('btnReset').onclick = ()=>{ handleResetPoints(); };

  /* Hồ sơ người chơi */
  document.getElementById('saveName').onclick=()=>{
    setName(document.getElementById('name').value);
    alert('Đã lưu');
  };

  /* Zone thêm mới */
  document.getElementById('addZone').onclick=()=>{
    const nameInp=document.getElementById('zName');
    const kindSel=document.getElementById('zKind');
    const nameVal=nameInp.value.trim();
    if(!nameVal){ alert('Nhập tên Zone'); return; }

    const file=document.getElementById('zBg').files[0];
    const kindVal=kindSel.value;

    function finishAdd(bgData){
      const z={
        name:nameVal,
        kind:kindVal,
        bg:bgData||''
      };
      addZone(z);
      nameInp.value='';
      kindSel.value='regular';
      document.getElementById('zBg').value='';
      viewSettings();
    }

    if(file){
      readFileAsDataURL(file, data=>finishAdd(data));
    }else{
      finishAdd('');
    }
  };

  /* Zone chỉnh sửa */
  const zoneTable=document.getElementById('zoneT');
  const handleZoneChange=(e)=>{
    const tr=e.target.closest('tr[data-id]'); if(!tr) return;
    const id=Number(tr.dataset.id);
    const name=e.target.name;
    if(!name) return;
    const val=e.target.value;
    updZone(id,{[name]:val});
  };
  zoneTable.oninput=handleZoneChange;
  zoneTable.onchange=handleZoneChange;

  /* Zone đổi hình nền */
  document.querySelectorAll('.bgUpload').forEach(inp=>{
    inp.onchange=()=>{
      const file=inp.files[0];
      const id=Number(inp.dataset.id);
      if(!file) return;
      readFileAsDataURL(file, data=>{
        updZone(id,{bg:data});
        viewSettings();
      });
    };
  });

  /* Zone xoá */
  document.querySelectorAll('.zdel').forEach(b=> b.onclick=()=>{
    delZone(Number(b.dataset.id));
    viewSettings();
  });

  /* Recurring */
  const typeSel=document.getElementById('rType');
  const daysRow=document.getElementById('rDaysRow');
  typeSel.onchange=()=>{
    daysRow.style.display = typeSel.value==='weekly'?'grid':'none';
  };

  document.getElementById('addRec').onclick=async ()=>{
    const text=document.getElementById('rText').value.trim();
    if(!text){ alert('Nhập mô tả'); return; }
    const zoneId=Number(document.getElementById('rZone').value);
    const type=typeSel.value;
    const days=[...daysRow.querySelectorAll('input:checked')].map(c=>Number(c.value));
    if(type==='weekly' && !days.length){
      alert('Chọn thứ');
      return;
    }
    await addRecurring({text, zoneId, type, days});
    document.getElementById('rText').value = '';
    document.getElementById('rZone').selectedIndex = 0;
    typeSel.value = 'daily';
    daysRow.style.display = 'none';
    [...daysRow.querySelectorAll('input[type="checkbox"]')].forEach(cb => cb.checked = false);
    viewSettings();
  };

  document.querySelectorAll('.rdel').forEach(b=> b.onclick=()=>{
    delRecurring(Number(b.dataset.id));
    viewSettings();
  });

  /* Local wipe */
  document.getElementById('wipeLocalBtn').onclick = ()=>{
    if(confirm('Xoá hồ sơ local và cache leaderboard trên máy này?')){
      wipeLocalPlayer();
    }
  };
}

/* ==============================
   ROUTER
============================== */
let currentTab='tasks';

function render(tab){
  currentTab = tab;
  renderHero();
  buildTabsBar(tab);

  if(tab==='tasks'){
    stopDaySyncMonitoring();
    syncDayWithCalendar();
    viewTasks();
    startDaySyncMonitoring();
    return;
  }

  stopDaySyncMonitoring();

  if(tab==='archive'){
    viewArchive();
  } else if(tab==='leaderboard'){
    viewLeaderboard();
  } else if(tab==='stats'){
    viewStats();
  } else if(tab==='settings'){
    if(ensureSettingsAuth()){
      viewSettings();
    } else {
      render('tasks');
    }
  } else {
    render('tasks');
  }
}

/* ==============================
   BOOT
============================== */
ensureName();
render('tasks');
fetchLeaderboardAndCache().catch(()=>{});
backgroundBoardRefresh();
if(lbTimer===null){
  // Runs for the duration of the session to keep leaderboard data fresh.
  lbTimer = setInterval(()=>{
    fetchLeaderboardAndCache().catch(()=>{});
  }, 60000);
}
</script>
</body>
</html>
